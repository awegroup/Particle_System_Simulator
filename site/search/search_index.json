{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"LightSailSim: Lightsail Design and Simulation Tool This repository features a set of tools for analysing the deformation of membranes using a particle system model. Installation Clone the repository: git clone https://github.com/markk116/LightSailSim.git Navigate to the project directory: cd LightSailSim Acknowledgement Based on Alexander Batchelor: Modeling kite deformation with particle system model.","title":"Home"},{"location":"#lightsailsim-lightsail-design-and-simulation-tool","text":"This repository features a set of tools for analysing the deformation of membranes using a particle system model.","title":"LightSailSim: Lightsail Design and Simulation Tool"},{"location":"#installation","text":"Clone the repository: git clone https://github.com/markk116/LightSailSim.git Navigate to the project directory: cd LightSailSim","title":"Installation"},{"location":"#acknowledgement","text":"Based on Alexander Batchelor: Modeling kite deformation with particle system model.","title":"Acknowledgement"},{"location":"docs/Implementation%20Notes/","tags":["python","lightsails"],"text":"Ideas Split ParticleSystem into ParticleSystem , ParticleSystemPlotter and ParticleSystemBuilder Plotting function [ Git Commit ] Using linecollection 3d to speed up plotting - ![[WhatsApp Image 2023-11-02 at 15.39.18_321bdfde.jpg]] - ![[Pasted image 20231102154512.png|300]] Further improvements [ ] Refine plotting function to give users more control of how it looks [ ] Refine plotting function to be in line with the recommended signature [ ] Refine plotting function to color the nodes by their strain Stress is harder, because I'd need to define an area to distribute the force over [ ] For plotting large meshes this is also slow. Consider plotting triangulation from point cloud instead. Finding surface [ Git commit ] Notes on proof of concept I think I should take strain into account - Options I have so far: - Feed nodes to scipy interpolater, interpolate surface, probe surface at each node point - Hard to define the area of each section then - Alexanders method (requires square mesh): define element as bounded by four nodes, calculate orientation and area of element, distribute forces evenly over surrounding nodes. - Somehow generate the voronoi diagram for the point cloud - From merigotVoronoiBasedCurvatureFeature2011 - \u201cthe most common method of estimating principal curvatures and principal curvature directions on point clouds is to locally t a polynomial of a given degree, and to analytically compute principal curvatures of this tted polynomial (M\u00e9rigot et al., 2011, p. 15) - The complexity of this is too high for me right now - So having done some research. The problem class is called Triangulation - A good option for doing this is using Delaunay triangulation - Which is implemented in Scipy: - scipy.spatial.Delaunay - it uses an external library to accomplish this, Qhull. It's important I pass the right options - Most notably, I think Qhull drops coplanar points, that way of course you represent the point cloud with as few triangles as possible = efficient - However, I need those triangles for force calculation - so I need to pas \"QJ\" - I can then distribute the forces of each triangle evenly over its points - I'm afraid this scales kinda poorly - Another option is constructing the voronoi diagram using the scipy method for that - However for 3d I will get a set of volumes. I would then have to slice that into the right sections. - Probably better just to stick with triangulation. - Made a testfile, then was like, wonder what it looks like, let's plot it - Found matplotlib tutourial - Turns out matplotlib is also calling Delaunay when plotting point clouds - ![[Pasted image 20231103113153.png]] - Plotting takes about the same amount of time as new method, but is much more responsive to mouse inputs. - Turns out I misread, scipy.spatial.Delaunay turns a 3d point cloud into tetrahedra, not triangles. - GPT-4 recommends using scipy.spatial.ConvexHull instead - But gives me just the bounding box, not all the triangles. - ![[Pasted image 20231103124011.png]] - Next option is to project the mesh onto a 2D plane, take the triangles there and reflate into 3D - that works ![[Pasted image 20231103123904.png]] - But is obviously very fragile, as it requires the mesh to be projectable onto a plane. The way Alexander does it is more robust. - I think I will move forward with this because it is fast, but I will have to keep in mind that this limitation exists, and document it. - Okay, now to calculate the areas and orientations - Cross product of two vectors gives me the area of the parallelogram - Divide by 2 for triangle area - and cross product also provides unit vector if I normalise it. - Got it! - ![[Pasted image 20231103133313.png]]![[Pasted image 20231103133321.png]] - Again, in terms of robustness it totally sucks: - ![[Pasted image 20231103133551.png]] - What's happening here is that it's shrinking in y due to the Poisson effect, and so it's filling in those little side triangles. - So this means I should initialise the triangles before simulating even 1 step. and then just update the positions after that - Which means I need a __initialize_triangles() that get's called only first time. - Now to divide the areas and orientations over each connected node! - Not sure if we can do this with numpy magic, I think we have to itterate which will be slow - Let's think about it. Goals: - Either - return area vector - or - return unit vector and area list - Former way more elegant - so we have a list of area vectors for each simplice - we could build a huge matrix that does the operation - iterate once, eat the suck and then be relatively fast after that - we can iterate over the nodes - if the node is part of a simplice - set the elements at the right indices to 1/3 - To apply use np.matmul - and then reshape input to be nx3 array - This would be much more elegant with tensors, but I'm afraid my brain too smooth for that - Plus it'd be hell to maintain for the next person - Okay flattening, using np.matmul and then reshaping kinda sorta worked ![[Pasted image 20231103153305.png]] - Basically, the points with more vertexes get a disproportionate amount of the area ![[Pasted image 20231103153635.png]] - I think we can fix this based on the angle of the triangle at the node - the 90 deg angle should get half the triangle, the 45 degree angles should get a quarter each. - for triangles that are all 60 degrees we get a third for each. - so it's just angle/180. - I realise this is true for planar geometry, but is different in 3d space - but the triangle is still planar and that's really the unit of analysis here - For the node that we randomly picked to calculate the area from we have the vectors so we can use the inner product rule $\\cos(\\theta) = \\frac{x \\cdot y}{|x||y|}$ - we can then use law of sines to find an other angle $\\frac{\\sin\\alpha}{a}=\\frac{\\sin\\beta}{b}$ - A little bit of messing around later I have: ![[Pasted image 20231103163443.png]] - Victory! - Ooh ooh, I could use the length of each of these vectors to set the particle mass accurately . - Next is implementing it in ParticleSystem - I will take the code I have and split it into multiple functions - I need to make a new private attribute to hold the conversion matrix - I need to make a __instantiate_surface() method that builds the mesh when the system is initialised - This needs optional arguments to handle setting the mass - Like an optional surface density argument function - could check for lambda function with type(rho)== types.FunctionType - I need a calulate_surfaces() method high level description so far: - Project mesh on z plane - triangulate using Delaunay's algorithm - calculate initial areas and angles of triangles - build conversion matrix for distributing areas over nodes Notes on implementation into ParticleSystem: Split into two functions First is __initialize_find_surface() which performs triangulation and sets up conversion matrix for surface calculation Second is find_surface() , which checks if the init has been performed, does so if that is not the case, and calculates the areas Also added a new plotting function: plot_triangulated_surface() . It plots triangulated surface for user inspection ![[Pasted image 20231106121047.png|300]]![[Pasted image 20231106121452.png|300]] Seems pretty fast too![[Pasted image 20231106121607.png]] Limitations ==!!! MESH MUST BE PROJECTABLE ONTO X-Y PLANE AT INIT!!!== For convenience could split more complicated systems into parts maybe. Like top and bottom half of an airfoil. ===Currently not taking changing element shape into account when distributing areas over the nodes=== but could rebuild the conversion matrix every n iterations. Assumes mesh with no holes in it. Further improvements [ ] Find a more robust triangulation algorithm PyMesh is an option PyMesh - Mesh Generation - Triangulation But it features the same issues, even worse they only accept coplanar point clouds. At least they way I'm doing it now I am already handling the projection. Could cut the mesh into bits in a smart way and project parts on a dedicated plane, then reinflate them and assemble the whole. Sounds like hell [ ] Allow projection onto arbitrary plane: https://en.wikipedia.org/wiki/Vector_projection ![[Pasted image 20231106105614.png]] [ ] Add option to periodically rebuild conversion matrix to account of element shape distortion [ ] Add support for holes Holes must be given in nested list of points that make up the holes Can then iterate over simplices and drop all those that are made up of just those points. [ ] Update plotting function to make sure mesh is initialized LaserBeam [ Git commit ] This one is pretty simple, just packaging lambda functions into a class. Representing polarization with a Jones vector. ![[Pasted image 20231107142641.png]] OpticalForceCalculator [ Git commit ] Notes Context This is a real big one I've kinda been procrastinating this one a bit because it requires me making decisions that have long term consequences Goal is to have a class that pulls together all the optical information such that it can be called each timestep to provide the optical forces It interacts with the ParticleSystem because it shares the list of Particle s Why a class rather than a method of ParticleSystem ? PS is growing a lot, starting to get really unwieldy The optical model requires a bunch of setup which would make setting up the PS even more annoying Better to sequence it into smaller steps. Helps with the flow for the users and facilitates use of Builder Design Pattern later. The math So what is it actually doing? Goal is to take incident ray, find the reflection and from that calculate the resulting force the incident rays we find by polling the LaserBeam.intensity_profile(x,y) at all node locations We assume it's always going to positive z Then we have to account for all the possible cases of optical materials in the particles Maybe we extract these on OpticalForceCalculator.__init__() Running through the general math: $$p_{photon}= \\frac{h}{\\lambda}$$ $$F_{optical} = \\frac{\\Delta p }{\\Delta t}$$ $$\\frac{\\Delta n_{photons}}{\\Delta t} = \\frac{P}{E_{photon}}=\\frac{P\\lambda}{hc}$$ $$\\Delta p = \\Delta n_{photons} p_{photon}$$ $$F_{optical} = \\frac{\\Delta n_{photons} p_{photon}}{\\Delta t}=\\frac{P\\lambda}{hc}\\frac{h}{\\lambda}= \\frac{P}{c}$$ Lol so we just come out to Power by speed of light. That's convenient. $$\\frac{\\Delta F_{optical}}{\\Delta Area}= \\frac{P}{c\\Delta Area}= \\frac{I}{c}$$ So for each element $$F_i = \\frac{A_i I_i}{c} \\text{, where } I_i = I(x_i,y_i)[0,0,1], A_i = a_i [n_{x,i},n_{y,i},n_{z,i}] $$ Cases Specular reflection First Specular reflection: we know force is normal to surface area the force is a function of the cosine of the angle between the normal vector and the incident light ray we can find this by using the dot product rule $A\\cdot B = |A||B| \\cos{\\theta}$ Got the right direction, now the magnitude![[Pasted image 20231122115701.png]] I think part of the problem is the way I define the laser beam intensity. Because it is kinda sloppy and so I don't have a nice reference I need to make a small library of testcases that I can borrow things from. Like standard instantiated meshes. Squares, circles, domes For now, I have set the beam to 100 GW / (10m * 10m) = 10 GW/m2 So the maximal total force is 100 GW/c = 333.6 N Got a good distribution for a flat sheet:![[Pasted image 20231122120230.png]] Actually, good enough for guvmn't work!![[Pasted image 20231122120608.png]] Okay, happy with that, for validation I gotta run this with angled planes and domes Doesn't run too slow either, DEFO could use some optimization but it won't break the bank right now. if really bad I could just update it every nth iteration anyway. Maybe update only when the kin damping is enacted, I have a feeling like there is something special case like about that. ![[Pasted image 20231122121159.png]] Axicon mirror Next case: One issue I have is that in a particle system I have poor reference for 'orientation' The axicon is defined by having a directing angle, but this is not the only parameter of importance, because the 'azimuth' of the direction angle also matters. If I define this w.r.t. the absolute coordinates, it would break on rotation of the whole. So maybe I have to define a local coordinate system as well. Can I use the triangulation I made already for this? maybe it's best for now to eschew this now and accept it as a limitation. This will only cause errors with large in plane translations, but I expect the dominating factor to be out of plane translations and rotations. So keeping it simple: Will effectively rotate the normal vector of the area ~~~First rotate from z+~~~ Let's keep it actually simple and just do x,y rotations Could just attach a rotation object to each particle Okay got it to work, what actually took the longest was getting the damn testcase to work because I kept getting twisted up with the rotations![[Pasted image 20231201133623.png]] But yea, got a multi pattern sail now On splitting cases: How to split cases I am a bit at a loss for how to do this efficiently Like, I don't want to iterate over the particle list and calculate the forces individually because that will eat performance So I want to do it using np.arrays my first idea was using a[a\\==x] notation to make a mask for each type and then calculating them separately, but I don't know how to put them together after doing the calculations. Unless I add a column with indices first, like pandas has built in then I can split it, work on it and put it together, then sort, finally cut off the index column Why not just use pandas then? Don't want to deal with extra package if I only need it for one thing. Had a chat with GPT-4, realised during that passing references is probably a better idea than passing copies of sub arrays, also for memory performance Like so ![[Pasted image 20231130120904.png]] So I'm going to loop over the enum, then create different views and make a dict of masks Currently doing this again every time, should put this in an __init_ method Limitations ==Breaks when sail is allowed to rotate around z== Further improvements [ ] Make init function for splitting cases to speed up program [ ] Split stability calculations away from force calculations [ ] Add rotation dependence for axicon mirror PhC [ ] Check if rotation is applied after cosine factor calculation rather than before V&V notes Run following cases: Flat square sheet Flat circle Flat sheet at 45 degree angles to the laserbeam Stability Coefficients Adding it to the optical force calculator because it seems to fit there nicely. Need to displace and rotate the particle system (reversibly) Procedure (pseudocode): Find center of mass start loop for each displacement displace sail calculate raw optical forces find net displacing and tilting reaction find stability coefficients via $k_q = \\frac{\\Delta F_q}{\\Delta q}$ un-displace sail end loop return values Implementation wise I think it might actually be nice to split it in a few functions: one that displaces the particles one that un-displaces them one that calculates COG one that puts it all together I am now thinking about the 2d example, but I have 2 translations and 2 rotations to worry about... x, y displacement rx, ry rotations Got the 2D case for displacement to work ![[Pasted image 20231124121043.png]] ![[Pasted image 20231124121057.png]] And now in 3D and actually around the center of mass![[Pasted image 20231124123431.png]] Now let's calculate the restoring forces. For translation we can simply sum over the forces For rotation we need to do some cross products. NOTE: Currently I added this all into the OpticalForceCalculator . It's growing a lot and so I have regrets about that. Here's my issue: I don't want to make it 'general mesh' tools because it has dependencies on the optical force things I can split it into a 'stability' class, but I feel there are similar issues there Maybe you'd wrap the optical forces in a generic external forces class that collects all external forces (if there are any other), which is then required on init of the stability tools. Okay got the basic logic running, seems to check out on the gut feel level![[Pasted image 20231124145008.png]] V&V notes Immediately some things I have to do come up: Write secondary function to test if it's linear What criteria? curvature? There's linear with respect to displacement, but should also check superposition holds. ( $Disp(x,y) = Disp(x)+Disp(y)$ ) displace only orthogonally or do random direction sampling? There is another big issue. Let's say we displace a small amount This will produce forces on the sail This will deform the sail Do I want the stability coefficients at the instant of displacement or should I let it settle in the new configuration first? I guess it depends on the settling time, if the settling takes very long it's arguable that the sail will have moved again so it's not relevant. Which means that ==this only works for very stable sails== Should be investigated #later Optimization This is a plot of the A matrix from the simulate function: - It's real sparse ![[Pasted image 20231106150757.png|450]] - Might offer speed up to use sparse matrix formats - Small test yields that this helps once a matrix becomes bigger than 250x250. Already really significantly so for a 1000x1000 matrix. - BICGSTAB takes a sparse matrix - And that speeds it up a lot actually (upper matrix multiplication, lower BicGStab) - ![[Pasted image 20231106160011.png]] - If we also build the system matrix more cleverly using the sp.sparse tools we can probably get better times even. Boundary conditions and reaction forces [ commit: Plane ] [ commit: Line ] Putting these two together because I will have they are interrelated Before we start cutting the patient open, let's MRI his heart. - the __fixed property is set on Particle at init, it is currently a bool - It is then used in update_pos and update_vel - It is also used in PS.simulate where it is used to zero out parts of the A matrix - ![[Pasted image 20231201134821.png]] - also when calculating external forces - and setting colour when plotting Now how to approach this: - My first idea is to replace the bool with a length 3 vector - If it's [1, 1, 1] then it should do nothing - Maybe I can set a bool for that - If it's [0, 0, 0] then it should fix the particle completely - Then I can mix and match for fixing in different DOF's - But here's where the magic comes in: if we put floats $\\epsilon[0,1]$ we can fix things to planes. - Effectively we would be projecting the motion onto the fixing plane and only allowing that - How to handle the projection? - How to alter the A matrix of jacobian to accurately reflect this Particle level Okay, second pass: - Effectively I'm projecting the motion onto a plane described by a vector. So the above notation won't work super well for fixing and having free particles - So I'll keep the Particle.__fixed and just add Particle.__constraint to hold the actual constraint, with a handy Particle.constraint_projection_matrix to pre-bake that - Since I'm projecting I also have to project the updated velocities and positions for the particles (almost forgot this) - But I should only project the change in velocity - So I subtract the current and matmul with the matrix nm - Okay, this part seems to check out ![[Pasted image 20231204143045.png]] - waitwaitwait I've now got a plane and a fixed constraint but no line constraint! - Fixed that now System level - Now let's work on the System level problem. Let's first set up the matrix to multiply the whole system - Hmm, what do I mean by this exactly? - I don't have to make one for the particles, because the update functions are taking care of that already. Would be faster to do it system-level but way less robust - So I guess I mean the matrix with which to multiply the jacobians - For example take a particle in 2D that is fixed to the plane normal to (1,1). Now if we pull this particle in the -x direction scaling the jacobian is not enough. Because the particle will comply to some degree, but also slide along the plane in the +y direction. So there is a coupling that arises. - I also realise that this isn't strictly needed, the code will just run fine like it is now. But the whole point of the bigstab is giving it information from the future with in the jacobian, so I think it will just converge much better if I do it correctly. - So, first understanding how the jacobians are assembled: - for each spring damper the jacobians are found - These are then assembled into two matrices, one for dx, other for dv - each J is used twice, once for the for between p1 and p2, and another time for p2 and p1 - The question is, is the effect of the constraint symmetric? - You know what, let's shelve this for now under 'further improvements' - Okay, when working on the reaction forces I found out that the line and plane constraints don't actually allow motion. This is because the fix particles are blanked out in the creation of the A matrix of the simulate function. - It should not zero them out - Two places I could intervene instead - don't zero things out but multiply appropriate things with projection - OR - don't zero things out and multiply jacobians appropriately. Further Improvements [ ] integrate the constraints into the jacobians ParticleSystem.find_reaction_forces() [ commit ] So, want to quickly retrieve reaction forces. Get forces, reshape into 3d array, then filter using fixed list. Now we have to do something a little more in order to find the right forces for the case that we have less than 3DOF constrained. Using the projection matrix we can find the kinematically enabled forces, and then we can subtract that from the original to find what the reaction forces are. This works! Mesher So, I got sick of doing this manually so I want to write something for this The architecture. I took one look at pymesh and decided it wouldn't work for me because I don't have much control over the actually mesh shape But the workflow of defining shapes and then meshing them makes sense so this is what I have in mind: A main Mesher class to hold the mesh .add_shape methods to add shapes to a list, together with the info about how it should be meshed .mesh_shapes to mesh them A Geometry class as abstract base for Rectangle Square can be a handle for Rectangle Elipse Circle can be a handle for Ellipse Can add Polygon later Each Geometry child class will implement methods for meshing itself in different ways. For example Rectangle.mesh_square() Ideas: - Ellipse can secretly call rectangle and perform a coordinate transformation on the final mesh to make it circular. What are the different parameters for meshing? - So, let's take a rectangle. I can imagine splitting it up into smaller rectangles. - Each can then contain a stretched unit cell of the mesh shape - I'd need to know how many cells to split it into - So we need width, length and a scaling parameter for the mesh - How to define the scaling parameter? - Preferably if we have two different rectangles the same inputs should yield the same result - maybe goal_unit_cell_edge_length ? - How do we connect Multiple shapes? - Don't think we need to so let's skip it for now.","title":"Implementation Notes"},{"location":"docs/Implementation%20Notes/#ideas","text":"Split ParticleSystem into ParticleSystem , ParticleSystemPlotter and ParticleSystemBuilder","title":"Ideas"},{"location":"docs/Implementation%20Notes/#plotting-function","text":"[ Git Commit ] Using linecollection 3d to speed up plotting - ![[WhatsApp Image 2023-11-02 at 15.39.18_321bdfde.jpg]] - ![[Pasted image 20231102154512.png|300]]","title":"Plotting function"},{"location":"docs/Implementation%20Notes/#further-improvements","text":"[ ] Refine plotting function to give users more control of how it looks [ ] Refine plotting function to be in line with the recommended signature [ ] Refine plotting function to color the nodes by their strain Stress is harder, because I'd need to define an area to distribute the force over [ ] For plotting large meshes this is also slow. Consider plotting triangulation from point cloud instead.","title":"Further improvements"},{"location":"docs/Implementation%20Notes/#finding-surface","text":"[ Git commit ]","title":"Finding surface"},{"location":"docs/Implementation%20Notes/#notes-on-proof-of-concept","text":"I think I should take strain into account - Options I have so far: - Feed nodes to scipy interpolater, interpolate surface, probe surface at each node point - Hard to define the area of each section then - Alexanders method (requires square mesh): define element as bounded by four nodes, calculate orientation and area of element, distribute forces evenly over surrounding nodes. - Somehow generate the voronoi diagram for the point cloud - From merigotVoronoiBasedCurvatureFeature2011 - \u201cthe most common method of estimating principal curvatures and principal curvature directions on point clouds is to locally t a polynomial of a given degree, and to analytically compute principal curvatures of this tted polynomial (M\u00e9rigot et al., 2011, p. 15) - The complexity of this is too high for me right now - So having done some research. The problem class is called Triangulation - A good option for doing this is using Delaunay triangulation - Which is implemented in Scipy: - scipy.spatial.Delaunay - it uses an external library to accomplish this, Qhull. It's important I pass the right options - Most notably, I think Qhull drops coplanar points, that way of course you represent the point cloud with as few triangles as possible = efficient - However, I need those triangles for force calculation - so I need to pas \"QJ\" - I can then distribute the forces of each triangle evenly over its points - I'm afraid this scales kinda poorly - Another option is constructing the voronoi diagram using the scipy method for that - However for 3d I will get a set of volumes. I would then have to slice that into the right sections. - Probably better just to stick with triangulation. - Made a testfile, then was like, wonder what it looks like, let's plot it - Found matplotlib tutourial - Turns out matplotlib is also calling Delaunay when plotting point clouds - ![[Pasted image 20231103113153.png]] - Plotting takes about the same amount of time as new method, but is much more responsive to mouse inputs. - Turns out I misread, scipy.spatial.Delaunay turns a 3d point cloud into tetrahedra, not triangles. - GPT-4 recommends using scipy.spatial.ConvexHull instead - But gives me just the bounding box, not all the triangles. - ![[Pasted image 20231103124011.png]] - Next option is to project the mesh onto a 2D plane, take the triangles there and reflate into 3D - that works ![[Pasted image 20231103123904.png]] - But is obviously very fragile, as it requires the mesh to be projectable onto a plane. The way Alexander does it is more robust. - I think I will move forward with this because it is fast, but I will have to keep in mind that this limitation exists, and document it. - Okay, now to calculate the areas and orientations - Cross product of two vectors gives me the area of the parallelogram - Divide by 2 for triangle area - and cross product also provides unit vector if I normalise it. - Got it! - ![[Pasted image 20231103133313.png]]![[Pasted image 20231103133321.png]] - Again, in terms of robustness it totally sucks: - ![[Pasted image 20231103133551.png]] - What's happening here is that it's shrinking in y due to the Poisson effect, and so it's filling in those little side triangles. - So this means I should initialise the triangles before simulating even 1 step. and then just update the positions after that - Which means I need a __initialize_triangles() that get's called only first time. - Now to divide the areas and orientations over each connected node! - Not sure if we can do this with numpy magic, I think we have to itterate which will be slow - Let's think about it. Goals: - Either - return area vector - or - return unit vector and area list - Former way more elegant - so we have a list of area vectors for each simplice - we could build a huge matrix that does the operation - iterate once, eat the suck and then be relatively fast after that - we can iterate over the nodes - if the node is part of a simplice - set the elements at the right indices to 1/3 - To apply use np.matmul - and then reshape input to be nx3 array - This would be much more elegant with tensors, but I'm afraid my brain too smooth for that - Plus it'd be hell to maintain for the next person - Okay flattening, using np.matmul and then reshaping kinda sorta worked ![[Pasted image 20231103153305.png]] - Basically, the points with more vertexes get a disproportionate amount of the area ![[Pasted image 20231103153635.png]] - I think we can fix this based on the angle of the triangle at the node - the 90 deg angle should get half the triangle, the 45 degree angles should get a quarter each. - for triangles that are all 60 degrees we get a third for each. - so it's just angle/180. - I realise this is true for planar geometry, but is different in 3d space - but the triangle is still planar and that's really the unit of analysis here - For the node that we randomly picked to calculate the area from we have the vectors so we can use the inner product rule $\\cos(\\theta) = \\frac{x \\cdot y}{|x||y|}$ - we can then use law of sines to find an other angle $\\frac{\\sin\\alpha}{a}=\\frac{\\sin\\beta}{b}$ - A little bit of messing around later I have: ![[Pasted image 20231103163443.png]] - Victory! - Ooh ooh, I could use the length of each of these vectors to set the particle mass accurately . - Next is implementing it in ParticleSystem - I will take the code I have and split it into multiple functions - I need to make a new private attribute to hold the conversion matrix - I need to make a __instantiate_surface() method that builds the mesh when the system is initialised - This needs optional arguments to handle setting the mass - Like an optional surface density argument function - could check for lambda function with type(rho)== types.FunctionType - I need a calulate_surfaces() method high level description so far: - Project mesh on z plane - triangulate using Delaunay's algorithm - calculate initial areas and angles of triangles - build conversion matrix for distributing areas over nodes","title":"Notes on proof of concept"},{"location":"docs/Implementation%20Notes/#notes-on-implementation-into-particlesystem","text":"Split into two functions First is __initialize_find_surface() which performs triangulation and sets up conversion matrix for surface calculation Second is find_surface() , which checks if the init has been performed, does so if that is not the case, and calculates the areas Also added a new plotting function: plot_triangulated_surface() . It plots triangulated surface for user inspection ![[Pasted image 20231106121047.png|300]]![[Pasted image 20231106121452.png|300]] Seems pretty fast too![[Pasted image 20231106121607.png]]","title":"Notes on implementation into ParticleSystem:"},{"location":"docs/Implementation%20Notes/#limitations","text":"==!!! MESH MUST BE PROJECTABLE ONTO X-Y PLANE AT INIT!!!== For convenience could split more complicated systems into parts maybe. Like top and bottom half of an airfoil. ===Currently not taking changing element shape into account when distributing areas over the nodes=== but could rebuild the conversion matrix every n iterations. Assumes mesh with no holes in it.","title":"Limitations"},{"location":"docs/Implementation%20Notes/#further-improvements_1","text":"[ ] Find a more robust triangulation algorithm PyMesh is an option PyMesh - Mesh Generation - Triangulation But it features the same issues, even worse they only accept coplanar point clouds. At least they way I'm doing it now I am already handling the projection. Could cut the mesh into bits in a smart way and project parts on a dedicated plane, then reinflate them and assemble the whole. Sounds like hell [ ] Allow projection onto arbitrary plane: https://en.wikipedia.org/wiki/Vector_projection ![[Pasted image 20231106105614.png]] [ ] Add option to periodically rebuild conversion matrix to account of element shape distortion [ ] Add support for holes Holes must be given in nested list of points that make up the holes Can then iterate over simplices and drop all those that are made up of just those points. [ ] Update plotting function to make sure mesh is initialized","title":"Further improvements"},{"location":"docs/Implementation%20Notes/#laserbeam","text":"[ Git commit ] This one is pretty simple, just packaging lambda functions into a class. Representing polarization with a Jones vector. ![[Pasted image 20231107142641.png]]","title":"LaserBeam"},{"location":"docs/Implementation%20Notes/#opticalforcecalculator","text":"[ Git commit ]","title":"OpticalForceCalculator"},{"location":"docs/Implementation%20Notes/#notes","text":"","title":"Notes"},{"location":"docs/Implementation%20Notes/#context","text":"This is a real big one I've kinda been procrastinating this one a bit because it requires me making decisions that have long term consequences Goal is to have a class that pulls together all the optical information such that it can be called each timestep to provide the optical forces It interacts with the ParticleSystem because it shares the list of Particle s Why a class rather than a method of ParticleSystem ? PS is growing a lot, starting to get really unwieldy The optical model requires a bunch of setup which would make setting up the PS even more annoying Better to sequence it into smaller steps. Helps with the flow for the users and facilitates use of Builder Design Pattern later.","title":"Context"},{"location":"docs/Implementation%20Notes/#the-math","text":"So what is it actually doing? Goal is to take incident ray, find the reflection and from that calculate the resulting force the incident rays we find by polling the LaserBeam.intensity_profile(x,y) at all node locations We assume it's always going to positive z Then we have to account for all the possible cases of optical materials in the particles Maybe we extract these on OpticalForceCalculator.__init__() Running through the general math: $$p_{photon}= \\frac{h}{\\lambda}$$ $$F_{optical} = \\frac{\\Delta p }{\\Delta t}$$ $$\\frac{\\Delta n_{photons}}{\\Delta t} = \\frac{P}{E_{photon}}=\\frac{P\\lambda}{hc}$$ $$\\Delta p = \\Delta n_{photons} p_{photon}$$ $$F_{optical} = \\frac{\\Delta n_{photons} p_{photon}}{\\Delta t}=\\frac{P\\lambda}{hc}\\frac{h}{\\lambda}= \\frac{P}{c}$$ Lol so we just come out to Power by speed of light. That's convenient. $$\\frac{\\Delta F_{optical}}{\\Delta Area}= \\frac{P}{c\\Delta Area}= \\frac{I}{c}$$ So for each element $$F_i = \\frac{A_i I_i}{c} \\text{, where } I_i = I(x_i,y_i)[0,0,1], A_i = a_i [n_{x,i},n_{y,i},n_{z,i}] $$","title":"The math"},{"location":"docs/Implementation%20Notes/#cases","text":"","title":"Cases"},{"location":"docs/Implementation%20Notes/#specular-reflection","text":"First Specular reflection: we know force is normal to surface area the force is a function of the cosine of the angle between the normal vector and the incident light ray we can find this by using the dot product rule $A\\cdot B = |A||B| \\cos{\\theta}$ Got the right direction, now the magnitude![[Pasted image 20231122115701.png]] I think part of the problem is the way I define the laser beam intensity. Because it is kinda sloppy and so I don't have a nice reference I need to make a small library of testcases that I can borrow things from. Like standard instantiated meshes. Squares, circles, domes For now, I have set the beam to 100 GW / (10m * 10m) = 10 GW/m2 So the maximal total force is 100 GW/c = 333.6 N Got a good distribution for a flat sheet:![[Pasted image 20231122120230.png]] Actually, good enough for guvmn't work!![[Pasted image 20231122120608.png]] Okay, happy with that, for validation I gotta run this with angled planes and domes Doesn't run too slow either, DEFO could use some optimization but it won't break the bank right now. if really bad I could just update it every nth iteration anyway. Maybe update only when the kin damping is enacted, I have a feeling like there is something special case like about that. ![[Pasted image 20231122121159.png]]","title":"Specular reflection"},{"location":"docs/Implementation%20Notes/#axicon-mirror","text":"Next case: One issue I have is that in a particle system I have poor reference for 'orientation' The axicon is defined by having a directing angle, but this is not the only parameter of importance, because the 'azimuth' of the direction angle also matters. If I define this w.r.t. the absolute coordinates, it would break on rotation of the whole. So maybe I have to define a local coordinate system as well. Can I use the triangulation I made already for this? maybe it's best for now to eschew this now and accept it as a limitation. This will only cause errors with large in plane translations, but I expect the dominating factor to be out of plane translations and rotations. So keeping it simple: Will effectively rotate the normal vector of the area ~~~First rotate from z+~~~ Let's keep it actually simple and just do x,y rotations Could just attach a rotation object to each particle Okay got it to work, what actually took the longest was getting the damn testcase to work because I kept getting twisted up with the rotations![[Pasted image 20231201133623.png]] But yea, got a multi pattern sail now","title":"Axicon mirror"},{"location":"docs/Implementation%20Notes/#on-splitting-cases","text":"How to split cases I am a bit at a loss for how to do this efficiently Like, I don't want to iterate over the particle list and calculate the forces individually because that will eat performance So I want to do it using np.arrays my first idea was using a[a\\==x] notation to make a mask for each type and then calculating them separately, but I don't know how to put them together after doing the calculations. Unless I add a column with indices first, like pandas has built in then I can split it, work on it and put it together, then sort, finally cut off the index column Why not just use pandas then? Don't want to deal with extra package if I only need it for one thing. Had a chat with GPT-4, realised during that passing references is probably a better idea than passing copies of sub arrays, also for memory performance Like so ![[Pasted image 20231130120904.png]] So I'm going to loop over the enum, then create different views and make a dict of masks Currently doing this again every time, should put this in an __init_ method","title":"On splitting cases:"},{"location":"docs/Implementation%20Notes/#limitations_1","text":"==Breaks when sail is allowed to rotate around z==","title":"Limitations"},{"location":"docs/Implementation%20Notes/#further-improvements_2","text":"[ ] Make init function for splitting cases to speed up program [ ] Split stability calculations away from force calculations [ ] Add rotation dependence for axicon mirror PhC [ ] Check if rotation is applied after cosine factor calculation rather than before","title":"Further improvements"},{"location":"docs/Implementation%20Notes/#vv-notes","text":"Run following cases: Flat square sheet Flat circle Flat sheet at 45 degree angles to the laserbeam","title":"V&amp;V notes"},{"location":"docs/Implementation%20Notes/#stability-coefficients","text":"Adding it to the optical force calculator because it seems to fit there nicely. Need to displace and rotate the particle system (reversibly) Procedure (pseudocode): Find center of mass start loop for each displacement displace sail calculate raw optical forces find net displacing and tilting reaction find stability coefficients via $k_q = \\frac{\\Delta F_q}{\\Delta q}$ un-displace sail end loop return values Implementation wise I think it might actually be nice to split it in a few functions: one that displaces the particles one that un-displaces them one that calculates COG one that puts it all together I am now thinking about the 2d example, but I have 2 translations and 2 rotations to worry about... x, y displacement rx, ry rotations Got the 2D case for displacement to work ![[Pasted image 20231124121043.png]] ![[Pasted image 20231124121057.png]] And now in 3D and actually around the center of mass![[Pasted image 20231124123431.png]] Now let's calculate the restoring forces. For translation we can simply sum over the forces For rotation we need to do some cross products. NOTE: Currently I added this all into the OpticalForceCalculator . It's growing a lot and so I have regrets about that. Here's my issue: I don't want to make it 'general mesh' tools because it has dependencies on the optical force things I can split it into a 'stability' class, but I feel there are similar issues there Maybe you'd wrap the optical forces in a generic external forces class that collects all external forces (if there are any other), which is then required on init of the stability tools. Okay got the basic logic running, seems to check out on the gut feel level![[Pasted image 20231124145008.png]]","title":"Stability Coefficients"},{"location":"docs/Implementation%20Notes/#vv-notes_1","text":"Immediately some things I have to do come up: Write secondary function to test if it's linear What criteria? curvature? There's linear with respect to displacement, but should also check superposition holds. ( $Disp(x,y) = Disp(x)+Disp(y)$ ) displace only orthogonally or do random direction sampling? There is another big issue. Let's say we displace a small amount This will produce forces on the sail This will deform the sail Do I want the stability coefficients at the instant of displacement or should I let it settle in the new configuration first? I guess it depends on the settling time, if the settling takes very long it's arguable that the sail will have moved again so it's not relevant. Which means that ==this only works for very stable sails== Should be investigated #later","title":"V&amp;V notes"},{"location":"docs/Implementation%20Notes/#optimization","text":"This is a plot of the A matrix from the simulate function: - It's real sparse ![[Pasted image 20231106150757.png|450]] - Might offer speed up to use sparse matrix formats - Small test yields that this helps once a matrix becomes bigger than 250x250. Already really significantly so for a 1000x1000 matrix. - BICGSTAB takes a sparse matrix - And that speeds it up a lot actually (upper matrix multiplication, lower BicGStab) - ![[Pasted image 20231106160011.png]] - If we also build the system matrix more cleverly using the sp.sparse tools we can probably get better times even.","title":"Optimization"},{"location":"docs/Implementation%20Notes/#boundary-conditions-and-reaction-forces","text":"[ commit: Plane ] [ commit: Line ] Putting these two together because I will have they are interrelated Before we start cutting the patient open, let's MRI his heart. - the __fixed property is set on Particle at init, it is currently a bool - It is then used in update_pos and update_vel - It is also used in PS.simulate where it is used to zero out parts of the A matrix - ![[Pasted image 20231201134821.png]] - also when calculating external forces - and setting colour when plotting Now how to approach this: - My first idea is to replace the bool with a length 3 vector - If it's [1, 1, 1] then it should do nothing - Maybe I can set a bool for that - If it's [0, 0, 0] then it should fix the particle completely - Then I can mix and match for fixing in different DOF's - But here's where the magic comes in: if we put floats $\\epsilon[0,1]$ we can fix things to planes. - Effectively we would be projecting the motion onto the fixing plane and only allowing that - How to handle the projection? - How to alter the A matrix of jacobian to accurately reflect this Particle level Okay, second pass: - Effectively I'm projecting the motion onto a plane described by a vector. So the above notation won't work super well for fixing and having free particles - So I'll keep the Particle.__fixed and just add Particle.__constraint to hold the actual constraint, with a handy Particle.constraint_projection_matrix to pre-bake that - Since I'm projecting I also have to project the updated velocities and positions for the particles (almost forgot this) - But I should only project the change in velocity - So I subtract the current and matmul with the matrix nm - Okay, this part seems to check out ![[Pasted image 20231204143045.png]] - waitwaitwait I've now got a plane and a fixed constraint but no line constraint! - Fixed that now System level - Now let's work on the System level problem. Let's first set up the matrix to multiply the whole system - Hmm, what do I mean by this exactly? - I don't have to make one for the particles, because the update functions are taking care of that already. Would be faster to do it system-level but way less robust - So I guess I mean the matrix with which to multiply the jacobians - For example take a particle in 2D that is fixed to the plane normal to (1,1). Now if we pull this particle in the -x direction scaling the jacobian is not enough. Because the particle will comply to some degree, but also slide along the plane in the +y direction. So there is a coupling that arises. - I also realise that this isn't strictly needed, the code will just run fine like it is now. But the whole point of the bigstab is giving it information from the future with in the jacobian, so I think it will just converge much better if I do it correctly. - So, first understanding how the jacobians are assembled: - for each spring damper the jacobians are found - These are then assembled into two matrices, one for dx, other for dv - each J is used twice, once for the for between p1 and p2, and another time for p2 and p1 - The question is, is the effect of the constraint symmetric? - You know what, let's shelve this for now under 'further improvements' - Okay, when working on the reaction forces I found out that the line and plane constraints don't actually allow motion. This is because the fix particles are blanked out in the creation of the A matrix of the simulate function. - It should not zero them out - Two places I could intervene instead - don't zero things out but multiply appropriate things with projection - OR - don't zero things out and multiply jacobians appropriately.","title":"Boundary conditions and reaction forces"},{"location":"docs/Implementation%20Notes/#further-improvements_3","text":"[ ] integrate the constraints into the jacobians","title":"Further Improvements"},{"location":"docs/Implementation%20Notes/#particlesystemfind_reaction_forces","text":"[ commit ] So, want to quickly retrieve reaction forces. Get forces, reshape into 3d array, then filter using fixed list. Now we have to do something a little more in order to find the right forces for the case that we have less than 3DOF constrained. Using the projection matrix we can find the kinematically enabled forces, and then we can subtract that from the original to find what the reaction forces are. This works!","title":"ParticleSystem.find_reaction_forces()"},{"location":"docs/Implementation%20Notes/#mesher","text":"So, I got sick of doing this manually so I want to write something for this","title":"Mesher"},{"location":"docs/Implementation%20Notes/#the-architecture","text":"I took one look at pymesh and decided it wouldn't work for me because I don't have much control over the actually mesh shape But the workflow of defining shapes and then meshing them makes sense so this is what I have in mind: A main Mesher class to hold the mesh .add_shape methods to add shapes to a list, together with the info about how it should be meshed .mesh_shapes to mesh them A Geometry class as abstract base for Rectangle Square can be a handle for Rectangle Elipse Circle can be a handle for Ellipse Can add Polygon later Each Geometry child class will implement methods for meshing itself in different ways. For example Rectangle.mesh_square() Ideas: - Ellipse can secretly call rectangle and perform a coordinate transformation on the final mesh to make it circular. What are the different parameters for meshing? - So, let's take a rectangle. I can imagine splitting it up into smaller rectangles. - Each can then contain a stretched unit cell of the mesh shape - I'd need to know how many cells to split it into - So we need width, length and a scaling parameter for the mesh - How to define the scaling parameter? - Preferably if we have two different rectangles the same inputs should yield the same result - maybe goal_unit_cell_edge_length ? - How do we connect Multiple shapes? - Don't think we need to so let's skip it for now.","title":"The architecture."},{"location":"docs/Tutourials/Tutorial%201/","text":"Tutourial 1 In this tutourial we will set up, mesh and simulate a basic membrane using the particle model. First we will import the right modules and set up some basic paramets for the simulation. import numpy as np import matplotlib.pyplot as plt import pandas as pd import sys , os sys . path . append ( os . path . abspath ( '..' )) from src.particleSystem.ParticleSystem import ParticleSystem # dictionary of required parameters params = { # model parameters \"k\" : 2 , # [N/m] spring stiffness \"c\" : 1 , # [N s/m] damping coefficient \"m_segment\" : 1 , # [kg] mass of each node # simulation settings \"dt\" : 0.1 , # [s] simulation timestep \"t_steps\" : 1000 , # [-] number of simulated time steps \"abs_tol\" : 1e-50 , # [m/s] absolute error tolerance iterative solver \"rel_tol\" : 1e-5 , # [-] relative error tolerance iterative solver \"max_iter\" : 1e5 , # [-] maximum number of iterations # physical parameters \"g\" : 9.807 # [m/s^2] gravitational acceleration } Meshing Meshing is fully manual at the moment. This means it is up to us to define a clever discretization for the object we want to simulate. For this tutourial we will simulate a ribbon experiencing an out of plane force. It is important to format the data such that we can feed it to the simulation library the way it expects it. We will have to supply three sturctures: The initial conditions : This represents the starting locations, velocities, masses and the boundary conditions of the nodes. Becuase they're point masses the only supported boundary conditions are fixed and free. The structure is a list with an entry for each node. It has the following form: initial_conditions = [[[ x_1 , y_1 , z_1 ], [ u_1 , v_1 , w_1 ], m_1 , Fixed_1 ], ... , [[ x_n , y_n , z_n ], [ u_n , v_n , w_n ], m_n , Fixed_n ]] The connectivity matrix : This is an n by n array where n is the total number of nodes. It represents the connections between nodes, where the indices of a cell in the array represents which cells are connected. A connection is marked by a non-zero entry. Four nodes connected in a line will have the following connectivity matrix: array ([[ 0. , 1. , 0. , 0. ], [ 1. , 0. , 1. , 0. ], [ 0. , 1. , 0. , 1. ], [ 0. , 0. , 1. , 0. ]]) The external forces : The external forces are passed to the simulation at every timestep. They are represented by F_x, F_y, F_z components for each node, but flattened into a 1D list. This allows the forces to be recalculated each timestep to take into account geometric non-linearities. The list has the form of: F_ext = [ F_x1 , F_y1 , F_z1 , ... , F_xn , F_yn , F_zn ] # grid discretization # We will use a rectanular grid of 6 x 3, which is 6 x 4 nodes spaced 1 unit apart grid_width = 3 grid_length = 6 params [ \"l0\" ] = 1 params [ \"n\" ] = ( grid_width + 1 ) * ( grid_length + 1 ) # Setting up the coordinates for the nodes mesh = np . meshgrid ( np . linspace ( 0 , grid_length , grid_length + 1 ), np . linspace ( 0 , grid_width , grid_width + 1 )) # Fitting it into the required format and setting boundary conditions # A the core of it this section converts the coordinate grids into a list of nodes initial_conditions = [] xy_coordinates = np . column_stack ( list ( zip ( mesh [ 0 ], mesh [ 1 ]))) . T xyz_coordinates = np . column_stack (( xy_coordinates , np . zeros ( len ( xy_coordinates )) . T )) for xyz in xyz_coordinates : fixed = False if xyz [ 0 ] == 0 or xyz [ 0 ] == grid_length : #For fixing the other boundary use \"xyz[1] == 0 or xyz[1] == grid_width\" fixed = True initial_conditions . append ([ xyz , np . zeros ( 3 ), params [ \"m_segment\" ], fixed ]) # Setting up the connectivity matrix connections = [] #We know that all the nodes are connected to those of the next row, which is grid_length+1 units further for i , node in enumerate ( initial_conditions [: - grid_length - 1 ]): # adding connextions in y-axis connections . append ([ i , i + grid_length + 1 , params [ 'k' ], params [ 'c' ]]) # We can do the same for the connections between the columns for i , node in enumerate ( initial_conditions ): # adding connections in x-axis if ( i + 1 ) % ( grid_length + 1 ): # Using modulus operator to exclude the nodes at the end of a row connections . append ([ i , i + 1 , params [ 'k' ], params [ 'c' ]]) # For convenience #connections = np.nonzero(np.triu(connectivity_matrix)) # Getting indices of cells with a connection #connections = np.column_stack((connections[0], connections[1])) Checking the mesh Now that we have set up the mesh, we can check if all the nodes and connection are in the right place by plotting it. # Applying external forces # Just using a simple load in z for this example f_ext = np . array ([[ 0 , 0 , 1 ] for i in range ( params [ 'n' ])]) . flatten () # Plotting mesh with external forces fig = plt . figure () ax = fig . add_subplot ( projection = '3d' ) for i , node in enumerate ( initial_conditions ): if node [ 3 ]: ax . scatter ( node [ 0 ][ 0 ], node [ 0 ][ 1 ], node [ 0 ][ 2 ], color = 'red' , marker = 'o' ) else : ax . scatter ( node [ 0 ][ 0 ], node [ 0 ][ 1 ], node [ 0 ][ 2 ], color = 'blue' , marker = 'o' ) ax . quiver ( * node [ 0 ] . tolist (), f_ext [ 3 * i ], f_ext [ 3 * i + 1 ], f_ext [ 3 * i + 2 ], length = 1 ) for connection in connections : line = np . column_stack ([ initial_conditions [ connection [ 0 ]][ 0 ], initial_conditions [ connection [ 1 ]][ 0 ]]) ax . plot ( line [ 0 ], line [ 1 ], line [ 2 ], color = 'black' ) ax . set_box_aspect (( grid_length , grid_width , 1 )) ax . set_zlim ( - 1 , 1 ) plt . title ( \"Initial state\" ) Text(0.5, 0.92, 'Initial state') Running the simulation Now we will set up the simulation itself. We need to determine for ourselves at what point we consider the simulation complete. In this case I have chosen a cutoff value for the kinetic energy. However, the simulation uses kinetic dampening so we cannot simply stop the simulation once the cutoff has been reached for the first time. This is because the velocities are all periodically set to zero. Hence we look at the highest value in a window of ten timesteps and stop the simulation when the highest one of the window is below our cutoff. # Now we can setup the particle system and simulation PS = ParticleSystem ( connections , initial_conditions , params ) t_vector = np . linspace ( params [ \"dt\" ], params [ \"t_steps\" ] * params [ \"dt\" ], params [ \"t_steps\" ]) final_step = 0 E_kin = [] f_int = [] # And run the simulation for step in t_vector : PS . kin_damp_sim ( f_ext ) final_step = step x , v , = PS . x_v_current E_kin . append ( np . linalg . norm ( v * v )) f_int . append ( np . linalg . norm ( PS . f_int )) converged = False if step > 10 : if np . max ( E_kin [ - 10 : - 1 ]) <= 1e-29 : converged = True if converged and step > 1 : print ( \"Kinetic damping PS converged\" , step ) break Kinetic damping PS converged 77.0 Let's take a look at the convergence behaviour of the simulation and see what we can learn. Let's also plot another common convergence criterium for comparison, the internal forces. We see that towards the end of the simulation the curve starts to flatten out for the Kinetic energy. This indicates that further simulation has decreasing marginal returns. The internal forces stabilise onto a set value and osclilate around this value. These dampened oscilations are very hard to visualise in one plot because of the diminishing size of the oscilations. # Let's check the convergence plot # Change these to zoom in on a specific region. plotstop = len ( E_kin ) plotstart = 0 plt . plot ( t_vector [: plotstop ], E_kin [: plotstop ], label = 'Kinetic Energy [J]' ) plt . plot ( t_vector [ plotstart : plotstop ], f_int [ plotstart : plotstop ], label = 'Internal Forces [N]' ) # Filtering out the peaks to mark where the kinetic damping algorithm kicked in. df = pd . DataFrame ( E_kin , index = t_vector [ 0 : plotstop ]) peaksonly = df [( df [ 0 ] . shift ( 1 ) < df [ 0 ]) & ( df [ 0 ] . shift ( - 1 ) < df [ 0 ])] plt . scatter ( peaksonly . index , peaksonly [ 0 ], c = 'r' , linewidths = 1 , marker = '+' , label = 'Kinetic Damping Enacted' ) plt . legend () plt . yscale ( 'log' ) plt . title ( \"Convergence Plot\" ) plt . xlabel ( 'Time [s]' ) plt . ylabel ( 'Quantity of interest' ) plt . xlim ( t_vector [ 0 ], t_vector [ plotstop ]) (0.1, 77.1) Reviewing results To view the results we will once again plot the system in 3D. To do this we first have to extract the current positions from the system. After that we can re-use the code from the beginning to visualise our result. final_positions = [[ particle . x , particle . v , particle . m , particle . fixed ] for particle in PS . particles ] # Plotting final results fig = plt . figure () ax = fig . add_subplot ( projection = '3d' ) for i , node in enumerate ( final_positions ): if node [ 3 ]: ax . scatter ( node [ 0 ][ 0 ], node [ 0 ][ 1 ], node [ 0 ][ 2 ], color = 'red' , marker = 'o' ) else : ax . scatter ( node [ 0 ][ 0 ], node [ 0 ][ 1 ], node [ 0 ][ 2 ], color = 'blue' , marker = 'o' ) ax . quiver ( * node [ 0 ] . tolist (), f_ext [ 3 * i ], f_ext [ 3 * i + 1 ], f_ext [ 3 * i + 2 ]) #, length = 0.3) for connection in connections : line = np . column_stack ([ final_positions [ connection [ 0 ]][ 0 ], final_positions [ connection [ 1 ]][ 0 ]]) ax . plot ( line [ 0 ], line [ 1 ], line [ 2 ], color = 'black' ) ax . legend ([ 'Fixed nodes' , 'Forces' , 'Free nodes' ]) # Finding bounding box and setting aspect ratio xyz = np . array ([ particle . x for particle in PS . particles ]) bb = [ np . ptp ( i ) for i in xyz . T ] ax . set_box_aspect ( bb ) plt . title ( \"Final state\" ) Text(0.5, 0.92, 'Final state')","title":"Tutorial 1"},{"location":"docs/Tutourials/Tutorial%201/#tutourial-1","text":"In this tutourial we will set up, mesh and simulate a basic membrane using the particle model. First we will import the right modules and set up some basic paramets for the simulation. import numpy as np import matplotlib.pyplot as plt import pandas as pd import sys , os sys . path . append ( os . path . abspath ( '..' )) from src.particleSystem.ParticleSystem import ParticleSystem # dictionary of required parameters params = { # model parameters \"k\" : 2 , # [N/m] spring stiffness \"c\" : 1 , # [N s/m] damping coefficient \"m_segment\" : 1 , # [kg] mass of each node # simulation settings \"dt\" : 0.1 , # [s] simulation timestep \"t_steps\" : 1000 , # [-] number of simulated time steps \"abs_tol\" : 1e-50 , # [m/s] absolute error tolerance iterative solver \"rel_tol\" : 1e-5 , # [-] relative error tolerance iterative solver \"max_iter\" : 1e5 , # [-] maximum number of iterations # physical parameters \"g\" : 9.807 # [m/s^2] gravitational acceleration }","title":"Tutourial 1"},{"location":"docs/Tutourials/Tutorial%201/#meshing","text":"Meshing is fully manual at the moment. This means it is up to us to define a clever discretization for the object we want to simulate. For this tutourial we will simulate a ribbon experiencing an out of plane force. It is important to format the data such that we can feed it to the simulation library the way it expects it. We will have to supply three sturctures: The initial conditions : This represents the starting locations, velocities, masses and the boundary conditions of the nodes. Becuase they're point masses the only supported boundary conditions are fixed and free. The structure is a list with an entry for each node. It has the following form: initial_conditions = [[[ x_1 , y_1 , z_1 ], [ u_1 , v_1 , w_1 ], m_1 , Fixed_1 ], ... , [[ x_n , y_n , z_n ], [ u_n , v_n , w_n ], m_n , Fixed_n ]] The connectivity matrix : This is an n by n array where n is the total number of nodes. It represents the connections between nodes, where the indices of a cell in the array represents which cells are connected. A connection is marked by a non-zero entry. Four nodes connected in a line will have the following connectivity matrix: array ([[ 0. , 1. , 0. , 0. ], [ 1. , 0. , 1. , 0. ], [ 0. , 1. , 0. , 1. ], [ 0. , 0. , 1. , 0. ]]) The external forces : The external forces are passed to the simulation at every timestep. They are represented by F_x, F_y, F_z components for each node, but flattened into a 1D list. This allows the forces to be recalculated each timestep to take into account geometric non-linearities. The list has the form of: F_ext = [ F_x1 , F_y1 , F_z1 , ... , F_xn , F_yn , F_zn ] # grid discretization # We will use a rectanular grid of 6 x 3, which is 6 x 4 nodes spaced 1 unit apart grid_width = 3 grid_length = 6 params [ \"l0\" ] = 1 params [ \"n\" ] = ( grid_width + 1 ) * ( grid_length + 1 ) # Setting up the coordinates for the nodes mesh = np . meshgrid ( np . linspace ( 0 , grid_length , grid_length + 1 ), np . linspace ( 0 , grid_width , grid_width + 1 )) # Fitting it into the required format and setting boundary conditions # A the core of it this section converts the coordinate grids into a list of nodes initial_conditions = [] xy_coordinates = np . column_stack ( list ( zip ( mesh [ 0 ], mesh [ 1 ]))) . T xyz_coordinates = np . column_stack (( xy_coordinates , np . zeros ( len ( xy_coordinates )) . T )) for xyz in xyz_coordinates : fixed = False if xyz [ 0 ] == 0 or xyz [ 0 ] == grid_length : #For fixing the other boundary use \"xyz[1] == 0 or xyz[1] == grid_width\" fixed = True initial_conditions . append ([ xyz , np . zeros ( 3 ), params [ \"m_segment\" ], fixed ]) # Setting up the connectivity matrix connections = [] #We know that all the nodes are connected to those of the next row, which is grid_length+1 units further for i , node in enumerate ( initial_conditions [: - grid_length - 1 ]): # adding connextions in y-axis connections . append ([ i , i + grid_length + 1 , params [ 'k' ], params [ 'c' ]]) # We can do the same for the connections between the columns for i , node in enumerate ( initial_conditions ): # adding connections in x-axis if ( i + 1 ) % ( grid_length + 1 ): # Using modulus operator to exclude the nodes at the end of a row connections . append ([ i , i + 1 , params [ 'k' ], params [ 'c' ]]) # For convenience #connections = np.nonzero(np.triu(connectivity_matrix)) # Getting indices of cells with a connection #connections = np.column_stack((connections[0], connections[1]))","title":"Meshing"},{"location":"docs/Tutourials/Tutorial%201/#checking-the-mesh","text":"Now that we have set up the mesh, we can check if all the nodes and connection are in the right place by plotting it. # Applying external forces # Just using a simple load in z for this example f_ext = np . array ([[ 0 , 0 , 1 ] for i in range ( params [ 'n' ])]) . flatten () # Plotting mesh with external forces fig = plt . figure () ax = fig . add_subplot ( projection = '3d' ) for i , node in enumerate ( initial_conditions ): if node [ 3 ]: ax . scatter ( node [ 0 ][ 0 ], node [ 0 ][ 1 ], node [ 0 ][ 2 ], color = 'red' , marker = 'o' ) else : ax . scatter ( node [ 0 ][ 0 ], node [ 0 ][ 1 ], node [ 0 ][ 2 ], color = 'blue' , marker = 'o' ) ax . quiver ( * node [ 0 ] . tolist (), f_ext [ 3 * i ], f_ext [ 3 * i + 1 ], f_ext [ 3 * i + 2 ], length = 1 ) for connection in connections : line = np . column_stack ([ initial_conditions [ connection [ 0 ]][ 0 ], initial_conditions [ connection [ 1 ]][ 0 ]]) ax . plot ( line [ 0 ], line [ 1 ], line [ 2 ], color = 'black' ) ax . set_box_aspect (( grid_length , grid_width , 1 )) ax . set_zlim ( - 1 , 1 ) plt . title ( \"Initial state\" ) Text(0.5, 0.92, 'Initial state')","title":"Checking the mesh"},{"location":"docs/Tutourials/Tutorial%201/#running-the-simulation","text":"Now we will set up the simulation itself. We need to determine for ourselves at what point we consider the simulation complete. In this case I have chosen a cutoff value for the kinetic energy. However, the simulation uses kinetic dampening so we cannot simply stop the simulation once the cutoff has been reached for the first time. This is because the velocities are all periodically set to zero. Hence we look at the highest value in a window of ten timesteps and stop the simulation when the highest one of the window is below our cutoff. # Now we can setup the particle system and simulation PS = ParticleSystem ( connections , initial_conditions , params ) t_vector = np . linspace ( params [ \"dt\" ], params [ \"t_steps\" ] * params [ \"dt\" ], params [ \"t_steps\" ]) final_step = 0 E_kin = [] f_int = [] # And run the simulation for step in t_vector : PS . kin_damp_sim ( f_ext ) final_step = step x , v , = PS . x_v_current E_kin . append ( np . linalg . norm ( v * v )) f_int . append ( np . linalg . norm ( PS . f_int )) converged = False if step > 10 : if np . max ( E_kin [ - 10 : - 1 ]) <= 1e-29 : converged = True if converged and step > 1 : print ( \"Kinetic damping PS converged\" , step ) break Kinetic damping PS converged 77.0 Let's take a look at the convergence behaviour of the simulation and see what we can learn. Let's also plot another common convergence criterium for comparison, the internal forces. We see that towards the end of the simulation the curve starts to flatten out for the Kinetic energy. This indicates that further simulation has decreasing marginal returns. The internal forces stabilise onto a set value and osclilate around this value. These dampened oscilations are very hard to visualise in one plot because of the diminishing size of the oscilations. # Let's check the convergence plot # Change these to zoom in on a specific region. plotstop = len ( E_kin ) plotstart = 0 plt . plot ( t_vector [: plotstop ], E_kin [: plotstop ], label = 'Kinetic Energy [J]' ) plt . plot ( t_vector [ plotstart : plotstop ], f_int [ plotstart : plotstop ], label = 'Internal Forces [N]' ) # Filtering out the peaks to mark where the kinetic damping algorithm kicked in. df = pd . DataFrame ( E_kin , index = t_vector [ 0 : plotstop ]) peaksonly = df [( df [ 0 ] . shift ( 1 ) < df [ 0 ]) & ( df [ 0 ] . shift ( - 1 ) < df [ 0 ])] plt . scatter ( peaksonly . index , peaksonly [ 0 ], c = 'r' , linewidths = 1 , marker = '+' , label = 'Kinetic Damping Enacted' ) plt . legend () plt . yscale ( 'log' ) plt . title ( \"Convergence Plot\" ) plt . xlabel ( 'Time [s]' ) plt . ylabel ( 'Quantity of interest' ) plt . xlim ( t_vector [ 0 ], t_vector [ plotstop ]) (0.1, 77.1)","title":"Running the simulation"},{"location":"docs/Tutourials/Tutorial%201/#reviewing-results","text":"To view the results we will once again plot the system in 3D. To do this we first have to extract the current positions from the system. After that we can re-use the code from the beginning to visualise our result. final_positions = [[ particle . x , particle . v , particle . m , particle . fixed ] for particle in PS . particles ] # Plotting final results fig = plt . figure () ax = fig . add_subplot ( projection = '3d' ) for i , node in enumerate ( final_positions ): if node [ 3 ]: ax . scatter ( node [ 0 ][ 0 ], node [ 0 ][ 1 ], node [ 0 ][ 2 ], color = 'red' , marker = 'o' ) else : ax . scatter ( node [ 0 ][ 0 ], node [ 0 ][ 1 ], node [ 0 ][ 2 ], color = 'blue' , marker = 'o' ) ax . quiver ( * node [ 0 ] . tolist (), f_ext [ 3 * i ], f_ext [ 3 * i + 1 ], f_ext [ 3 * i + 2 ]) #, length = 0.3) for connection in connections : line = np . column_stack ([ final_positions [ connection [ 0 ]][ 0 ], final_positions [ connection [ 1 ]][ 0 ]]) ax . plot ( line [ 0 ], line [ 1 ], line [ 2 ], color = 'black' ) ax . legend ([ 'Fixed nodes' , 'Forces' , 'Free nodes' ]) # Finding bounding box and setting aspect ratio xyz = np . array ([ particle . x for particle in PS . particles ]) bb = [ np . ptp ( i ) for i in xyz . T ] ax . set_box_aspect ( bb ) plt . title ( \"Final state\" ) Text(0.5, 0.92, 'Final state')","title":"Reviewing results"},{"location":"reference/src/ExternalForces/LaserBeam/","text":"Module src.ExternalForces.LaserBeam Child Class 'LaserBeam', for holding laser atributes View Source # -*- coding: utf-8 -*- \"\"\" Child Class 'LaserBeam', for holding laser atributes \"\"\" from typing import Callable import numpy as np import matplotlib.pyplot as plt from src.particleSystem.SystemObject import SystemObject class LaserBeam ( SystemObject ): \"\"\" Holds information about the laserbeam Attributes --------- intensity_profile : Callable[[float, float], float] Maps (x, y) to the scalar intensity profile of the beam. polarization_map : Callable[[float, float], np.ndarray] Maps (x, y) to the polarization profile of the beam represented as a Jones vector. \"\"\" def __init__ ( self , intensity_profile : Callable [[ float , float ], float ], polarization_map : Callable [[ float , float ], list [ np . complex_ , np . complex_ ]] ): \"\"\" Initializes a laserbeam based on input parameters The polarization profile represents the Jones vector. Its datatype is allowed to be complex in order to capture both linear and circular polarization states. Parameters ---------- intensity_profile : Callable[[float, float], float] A numpy compatible function that maps x, y to the scalar intensity profile of the beam. [W/m^2] polarization_map : Callable[[float, float], np.ndarray] A numpy compatible function that maps x, y to the polarization profile of the beam. [-] Returns ------- None. \"\"\" self . intensity_profile = intensity_profile self . polarization_map = polarization_map def __str__ ( self ): print ( \"LaserBeam instantiated with attributes:\" ) print ( f \"polarisation_map: { self . polarization_map } \" ) print ( f \"intensity_profile: { self . intensity_profile } \" ) return \"\" def plot ( self , ax = None , x_range = [ - 1 , 1 ], y_range = [ - 1 , 1 ], n = 100 ): n_sqrt = int ( np . sqrt ( n )) x = np . linspace ( x_range [ 0 ], x_range [ 1 ], n_sqrt ) y = np . linspace ( y_range [ 0 ], y_range [ 1 ], n_sqrt ) x , y = np . meshgrid ( x , y ) ip = self . intensity_profile ( x , y ) pol = self . polarization_map ( x , y ) if ax == None : fig = plt . figure () ax = fig . add_subplot ( projection = '3d' ) ax . plot_surface ( x , y , ip , label = \"Intensity\" ) ax . quiver ( x , y , ip , pol [ 0 ], pol [ 1 ], 0 , length = 0.1 , color = 'r' , label = \"Polarization\" ) ax . set_xlabel ( 'x' ) ax . set_ylabel ( 'y' ) plt . legend () return ax if __name__ == \"__main__\" : mu = 0 sigma = 0.5 LB = LaserBeam ( lambda x , y : np . exp ( - 1 / 2 * (( x - mu ) / sigma ) ** 2 - 1 / 2 * (( y - mu ) / sigma ) ** 2 ), lambda x , y : np . array ([ 1 + 0 j , 0 + 0 j ]) ) LB . plot () Classes LaserBeam class LaserBeam ( intensity_profile : Callable [[ float , float ], float ], polarization_map : Callable [[ float , float ], list [ numpy . complex128 , numpy . complex128 ]] ) Holds information about the laserbeam Attributes intensity_profile : Callable[[float, float], float] Maps (x, y) to the scalar intensity profile of the beam. polarization_map : Callable[[float, float], np.ndarray] Maps (x, y) to the polarization profile of the beam represented as a Jones vector. View Source class LaserBeam(SystemObject): \"\"\" Holds information about the laserbeam Attributes --------- intensity_profile : Callable [[ float , float ] , float ] Maps (x , y) to the scalar intensity profile of the beam . polarization_map : Callable [[ float , float ] , np . ndarray ] Maps (x , y) to the polarization profile of the beam represented as a Jones vector . \"\"\" def __init__(self , intensity_profile: Callable [[ float , float ] , float ] , polarization_map: Callable [[ float , float ] , list [ np . complex_ , np . complex_ ]] ): \"\"\" Initializes a laserbeam based on input parameters The polarization profile represents the Jones vector . Its datatype is allowed to be complex in order to capture both linear and circular polarization states . Parameters ---------- intensity_profile : Callable [[ float , float ] , float ] A numpy compatible function that maps x , y to the scalar intensity profile of the beam . [ W/m^2 ] polarization_map : Callable [[ float , float ] , np . ndarray ] A numpy compatible function that maps x , y to the polarization profile of the beam . [ - ] Returns ------- None . \"\"\" self . intensity_profile = intensity_profile self . polarization_map = polarization_map def __str__(self): print(\"LaserBeam instantiated with attributes:\") print(f\"polarisation_map: {self . polarization_map}\") print(f\"intensity_profile: {self . intensity_profile}\") return \"\" def plot(self , ax = None , x_range = [ - 1 , 1 ] , y_range = [ - 1 , 1 ] , n = 100): n_sqrt = int(np . sqrt(n)) x = np . linspace(x_range [ 0 ] , x_range [ 1 ] , n_sqrt) y = np . linspace(y_range [ 0 ] , y_range [ 1 ] , n_sqrt) x , y = np . meshgrid(x , y) ip = self . intensity_profile(x , y) pol = self . polarization_map(x , y) if ax == None: fig = plt . figure() ax = fig . add_subplot(projection = '3d') ax . plot_surface(x , y , ip , label = \"Intensity\") ax . quiver(x , y , ip , pol [ 0 ] , pol [ 1 ] , 0 , length = 0 . 1 , color='r' , label = \"Polarization\") ax . set_xlabel('x') ax . set_ylabel('y') plt . legend() return ax Ancestors (in MRO) src.particleSystem.SystemObject.SystemObject abc.ABC Methods plot def plot ( self , ax = None , x_range = [ - 1 , 1 ], y_range = [ - 1 , 1 ], n = 100 ) View Source def plot ( self , ax = None , x_range = [ - 1 , 1 ], y_range = [ - 1 , 1 ], n = 100 ) : n_sqrt = int ( np . sqrt ( n )) x = np . linspace ( x_range [ 0 ], x_range [ 1 ], n_sqrt ) y = np . linspace ( y_range [ 0 ], y_range [ 1 ], n_sqrt ) x , y = np . meshgrid ( x , y ) ip = self . intensity_profile ( x , y ) pol = self . polarization_map ( x , y ) if ax == None : fig = plt . figure () ax = fig . add_subplot ( projection = '3d' ) ax . plot_surface ( x , y , ip , label = \"Intensity\" ) ax . quiver ( x , y , ip , pol [ 0 ], pol [ 1 ], 0 , length = 0 . 1 , color = 'r' , label = \"Polarization\" ) ax . set_xlabel ( 'x' ) ax . set_ylabel ( 'y' ) plt . legend () return ax","title":"Laserbeam"},{"location":"reference/src/ExternalForces/LaserBeam/#module-srcexternalforceslaserbeam","text":"Child Class 'LaserBeam', for holding laser atributes View Source # -*- coding: utf-8 -*- \"\"\" Child Class 'LaserBeam', for holding laser atributes \"\"\" from typing import Callable import numpy as np import matplotlib.pyplot as plt from src.particleSystem.SystemObject import SystemObject class LaserBeam ( SystemObject ): \"\"\" Holds information about the laserbeam Attributes --------- intensity_profile : Callable[[float, float], float] Maps (x, y) to the scalar intensity profile of the beam. polarization_map : Callable[[float, float], np.ndarray] Maps (x, y) to the polarization profile of the beam represented as a Jones vector. \"\"\" def __init__ ( self , intensity_profile : Callable [[ float , float ], float ], polarization_map : Callable [[ float , float ], list [ np . complex_ , np . complex_ ]] ): \"\"\" Initializes a laserbeam based on input parameters The polarization profile represents the Jones vector. Its datatype is allowed to be complex in order to capture both linear and circular polarization states. Parameters ---------- intensity_profile : Callable[[float, float], float] A numpy compatible function that maps x, y to the scalar intensity profile of the beam. [W/m^2] polarization_map : Callable[[float, float], np.ndarray] A numpy compatible function that maps x, y to the polarization profile of the beam. [-] Returns ------- None. \"\"\" self . intensity_profile = intensity_profile self . polarization_map = polarization_map def __str__ ( self ): print ( \"LaserBeam instantiated with attributes:\" ) print ( f \"polarisation_map: { self . polarization_map } \" ) print ( f \"intensity_profile: { self . intensity_profile } \" ) return \"\" def plot ( self , ax = None , x_range = [ - 1 , 1 ], y_range = [ - 1 , 1 ], n = 100 ): n_sqrt = int ( np . sqrt ( n )) x = np . linspace ( x_range [ 0 ], x_range [ 1 ], n_sqrt ) y = np . linspace ( y_range [ 0 ], y_range [ 1 ], n_sqrt ) x , y = np . meshgrid ( x , y ) ip = self . intensity_profile ( x , y ) pol = self . polarization_map ( x , y ) if ax == None : fig = plt . figure () ax = fig . add_subplot ( projection = '3d' ) ax . plot_surface ( x , y , ip , label = \"Intensity\" ) ax . quiver ( x , y , ip , pol [ 0 ], pol [ 1 ], 0 , length = 0.1 , color = 'r' , label = \"Polarization\" ) ax . set_xlabel ( 'x' ) ax . set_ylabel ( 'y' ) plt . legend () return ax if __name__ == \"__main__\" : mu = 0 sigma = 0.5 LB = LaserBeam ( lambda x , y : np . exp ( - 1 / 2 * (( x - mu ) / sigma ) ** 2 - 1 / 2 * (( y - mu ) / sigma ) ** 2 ), lambda x , y : np . array ([ 1 + 0 j , 0 + 0 j ]) ) LB . plot ()","title":"Module src.ExternalForces.LaserBeam"},{"location":"reference/src/ExternalForces/LaserBeam/#classes","text":"","title":"Classes"},{"location":"reference/src/ExternalForces/LaserBeam/#laserbeam","text":"class LaserBeam ( intensity_profile : Callable [[ float , float ], float ], polarization_map : Callable [[ float , float ], list [ numpy . complex128 , numpy . complex128 ]] ) Holds information about the laserbeam","title":"LaserBeam"},{"location":"reference/src/ExternalForces/LaserBeam/#attributes","text":"intensity_profile : Callable[[float, float], float] Maps (x, y) to the scalar intensity profile of the beam. polarization_map : Callable[[float, float], np.ndarray] Maps (x, y) to the polarization profile of the beam represented as a Jones vector. View Source class LaserBeam(SystemObject): \"\"\" Holds information about the laserbeam Attributes --------- intensity_profile : Callable [[ float , float ] , float ] Maps (x , y) to the scalar intensity profile of the beam . polarization_map : Callable [[ float , float ] , np . ndarray ] Maps (x , y) to the polarization profile of the beam represented as a Jones vector . \"\"\" def __init__(self , intensity_profile: Callable [[ float , float ] , float ] , polarization_map: Callable [[ float , float ] , list [ np . complex_ , np . complex_ ]] ): \"\"\" Initializes a laserbeam based on input parameters The polarization profile represents the Jones vector . Its datatype is allowed to be complex in order to capture both linear and circular polarization states . Parameters ---------- intensity_profile : Callable [[ float , float ] , float ] A numpy compatible function that maps x , y to the scalar intensity profile of the beam . [ W/m^2 ] polarization_map : Callable [[ float , float ] , np . ndarray ] A numpy compatible function that maps x , y to the polarization profile of the beam . [ - ] Returns ------- None . \"\"\" self . intensity_profile = intensity_profile self . polarization_map = polarization_map def __str__(self): print(\"LaserBeam instantiated with attributes:\") print(f\"polarisation_map: {self . polarization_map}\") print(f\"intensity_profile: {self . intensity_profile}\") return \"\" def plot(self , ax = None , x_range = [ - 1 , 1 ] , y_range = [ - 1 , 1 ] , n = 100): n_sqrt = int(np . sqrt(n)) x = np . linspace(x_range [ 0 ] , x_range [ 1 ] , n_sqrt) y = np . linspace(y_range [ 0 ] , y_range [ 1 ] , n_sqrt) x , y = np . meshgrid(x , y) ip = self . intensity_profile(x , y) pol = self . polarization_map(x , y) if ax == None: fig = plt . figure() ax = fig . add_subplot(projection = '3d') ax . plot_surface(x , y , ip , label = \"Intensity\") ax . quiver(x , y , ip , pol [ 0 ] , pol [ 1 ] , 0 , length = 0 . 1 , color='r' , label = \"Polarization\") ax . set_xlabel('x') ax . set_ylabel('y') plt . legend() return ax","title":"Attributes"},{"location":"reference/src/ExternalForces/LaserBeam/#ancestors-in-mro","text":"src.particleSystem.SystemObject.SystemObject abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/src/ExternalForces/LaserBeam/#methods","text":"","title":"Methods"},{"location":"reference/src/ExternalForces/LaserBeam/#plot","text":"def plot ( self , ax = None , x_range = [ - 1 , 1 ], y_range = [ - 1 , 1 ], n = 100 ) View Source def plot ( self , ax = None , x_range = [ - 1 , 1 ], y_range = [ - 1 , 1 ], n = 100 ) : n_sqrt = int ( np . sqrt ( n )) x = np . linspace ( x_range [ 0 ], x_range [ 1 ], n_sqrt ) y = np . linspace ( y_range [ 0 ], y_range [ 1 ], n_sqrt ) x , y = np . meshgrid ( x , y ) ip = self . intensity_profile ( x , y ) pol = self . polarization_map ( x , y ) if ax == None : fig = plt . figure () ax = fig . add_subplot ( projection = '3d' ) ax . plot_surface ( x , y , ip , label = \"Intensity\" ) ax . quiver ( x , y , ip , pol [ 0 ], pol [ 1 ], 0 , length = 0 . 1 , color = 'r' , label = \"Polarization\" ) ax . set_xlabel ( 'x' ) ax . set_ylabel ( 'y' ) plt . legend () return ax","title":"plot"},{"location":"reference/src/ExternalForces/OpticalForceCalculator/","text":"Module src.ExternalForces.OpticalForceCalculator Optical force calculation framework Created on Tue Nov 7 14:19:21 2023 View Source # -*- coding: utf-8 -*- \"\"\" Optical force calculation framework Created on Tue Nov 7 14:19:21 2023 @author: Mark Kalsbeek \"\"\" from enum import Enum from itertools import compress import numpy as np import numpy.typing as npt import scipy as sp from scipy.constants import c from scipy.spatial.transform import Rotation from src.particleSystem.Force import Force import logging class OpticalForceCalculator ( Force ): \"\"\" Handles the calculation of forces arising from optical pressure \"\"\" def __init__ ( self , ParticleSystem , LaserBeam ): self . ParticleSystem = ParticleSystem self . LaserBeam = LaserBeam if not hasattr ( self . ParticleSystem . particles [ 0 ], 'optical_type' ): raise AttributeError ( \"ParticleSystem does not have any optical properties set!\" ) super () . __init__ () return def __str__ ( self ): print ( \"OpticalForceCalculator object instantiated with attributes:\" ) print ( f \"ParticleSystem: \\n { self . ParticleSystem } \" ) print ( f \"LaserBeam: \\n { self . LaserBeam } \" ) return \"\" def force_value ( self ): PS = self . ParticleSystem LB = self . LaserBeam area_vectors = PS . find_surface () locations , _ = PS . x_v_current_3D forces = np . zeros ( locations . shape ) # adding index to locations for splitting and rejoining if not hasattr ( self , 'optical_type_mask' ): self . create_optical_type_mask () # ! Note ! This bakes in implicitly that the orientation of the light # vector is in z+ direction intensity_vectors = np . array ([[ 0 , 0 , LB . intensity_profile ( x , y )] for x , y , z in locations ]) for optical_type in self . optical_type_mask . keys (): if optical_type == ParticleOpticalPropertyType . SPECULAR : mask = self . optical_type_mask [ optical_type ] forces [ mask ] = self . calculate_specular_force ( area_vectors [ mask ], intensity_vectors [ mask ]) elif optical_type == ParticleOpticalPropertyType . AXICONGRATING : mask = self . optical_type_mask [ optical_type ] filtered_particles = compress ( PS . particles , mask ) axicon_angle = [ i . axicon_angle for i in filtered_particles ] forces [ mask ] = self . calculate_axicongrating_force ( area_vectors [ mask ], intensity_vectors [ mask ], axicon_angle ) return forces def calculate_specular_force ( self , area_vectors , intensity_vectors ): abs_area_vectors = np . linalg . norm ( area_vectors , axis = 1 ) abs_intensity_vectors = intensity_vectors [:, 2 ] # assumes z+ vector # The next operation divides by abs_intensity_vectors, which is undone later # this is to improve legibility because it is more analogous to the # cosine dot product rule cosine_factor = ( np . sum ( area_vectors * intensity_vectors , axis = 1 ) / ( abs_area_vectors * abs_intensity_vectors ) ) forces = area_vectors . copy () for i in range ( 3 ): forces [:, i ] *= abs_intensity_vectors * cosine_factor / c return forces def calculate_axicongrating_force ( self , area_vectors , intensity_vectors , axicon_angle ): rotation_super_matrix = sp . linalg . block_diag ( * axicon_angle ) area_vectors = rotation_super_matrix . dot ( np . hstack ( area_vectors ) . T ) area_vectors = np . reshape ( area_vectors , [ int ( area_vectors . shape [ 0 ] / 3 ), 3 ]) abs_area_vectors = np . linalg . norm ( area_vectors , axis = 1 ) abs_intensity_vectors = intensity_vectors [:, 2 ] # assumes z+ vector # The next operation divides by abs_intensity_vectors, which is undone later # this is to improve legibility because it is more analogous to the # cosine dot product rule cosine_factor = ( np . sum ( area_vectors * intensity_vectors , axis = 1 ) / ( abs_area_vectors * abs_intensity_vectors ) ) forces = area_vectors . copy () for i in range ( 3 ): forces [:, i ] *= abs_intensity_vectors * cosine_factor / c return forces def create_optical_type_mask ( self ): \"\"\" loops over particles and sets a dict of masks onto self formatted as {type:mask} Raises ------ AttributeError Raises error when particles have no optical type set. \"\"\" optical_type_list = [] error_index_list = [] for i , particle in enumerate ( self . ParticleSystem . particles ): if hasattr ( particle , 'optical_type' ): optical_type_list . append ( particle . optical_type ) else : error_index_list . append ( i ) if len ( error_index_list ) > 0 : raise AttributeError ( \"All particles should have an optical type\" \" set prior to calculation of optical forces.\" \" Currently the particles with indices\" f \" { error_index_list } have no property set\" ) optical_type_list = np . array ( optical_type_list ) self . optical_type_mask = {} for optical_type in ParticleOpticalPropertyType : mask = optical_type_list == optical_type if sum ( mask ) > 0 : self . optical_type_mask [ optical_type ] = mask def calculate_stability_coefficients ( self , displacement_range = [ 0.1 , 5 ]): \"\"\" Calculates the stability coefficients for the particle system Arguments --------- displacement_range : list list of length two representing the displacement magnitudes to perform the stability test. First value represents lateral displacement in meters. Second value represents tilt angle around the centre of mass in degrees. Returns ------- stability_matrix : npt.arraytype 6x6 matrix holding the stability terms of the system using notation convention of Jacobian \"\"\" q , alpha = displacement_range displacement_vectors = np . array ([[ q , 0 , 0 , 0 , 0 , 0 ], [ 0 , q , 0 , 0 , 0 , 0 ], [ 0 , 0 , q , 0 , 0 , 0 ], [ 0 , 0 , 0 , alpha , 0 , 0 ], [ 0 , 0 , 0 , 0 , alpha , 0 ], [ 0 , 0 , 0 , 0 , 0 , alpha ]]) jacobian = np . zeros (( 6 , 6 )) for i , vector in enumerate ( displacement_vectors ): jacobian [:, i ] = np . hstack ( self . calculate_force_gradient ( vector )) return jacobian def calculate_force_gradient ( self , displacement_vector : npt . ArrayLike ): original = self . calculate_restoring_forces () self . displace_particle_system ( displacement_vector ) reaction = self . calculate_restoring_forces () self . un_displace_particle_system () displacement = displacement_vector [ displacement_vector != 0 ] if len ( displacement ) > 1 : raise AttributeError ( f \"Expected vector with only one nonzero value,\" \"instead got {displacement_vector} \" ) k_trans = ( reaction [ 0 ] - original [ 0 ]) / displacement k_rot = ( reaction [ 1 ] - original [ 1 ]) / displacement return k_trans , k_rot def displace_particle_system ( self , displacement : list ): \"\"\" displaces the associated particle system with the prescribed amount around the center of mass. Arguments ---------- displacement_range : list list of length 6 representing the displacement magnitudes to perform the stability test. First three values represent lateral displacement in meters. Next three values represent tilt angle around the centre of mass in degrees. \"\"\" if len ( displacement ) != 6 : raise AttributeError ( \"Expected list of 6 arguments representing \" \"x,y,z,rx,ry,rz, got list of length {} instead\" . format ( len ( displacement ))) self . ParticleSystem . current_displacement = displacement qx , qy , qz , * _ = displacement COM = self . find_center_of_mass () locations , _ = PS . x_v_current_3D self . translate_mesh ( locations , - COM ) new_locations = self . rotate_mesh ( locations , displacement [ 3 :]) new_locations = self . translate_mesh ( new_locations , displacement [: 3 ]) new_locations = self . translate_mesh ( new_locations , COM ) for i , location in enumerate ( new_locations ): # 'Unsafe' update needed to move fixed particles as well self . ParticleSystem . particles [ i ] . update_pos_unsafe ( location ) def un_displace_particle_system ( self ): \"\"\" Reverses current mesh displacement of the associated particle system. \"\"\" if not hasattr ( self . ParticleSystem , 'current_displacement' ): raise AttributeError ( \"Particle System is not currently displaced\" ) elif type ( self . ParticleSystem . current_displacement ) == type ( None ): raise AttributeError ( \"Particle System is not currently displaced\" ) current_displacement = self . ParticleSystem . current_displacement reverse_displacement = - np . array ( current_displacement ) self . displace_particle_system ( reverse_displacement ) self . ParticleSystem . current_displacement = None def find_center_of_mass ( self ): \"\"\" finds coordinates of center of mass of current mesh Returns ------- COM : npt.ArrayLike [x,y,z] vector of center of mass \"\"\" locations , _ = PS . x_v_current_3D COM = np . mean ( locations , axis = 0 ) return COM def translate_mesh ( self , mesh , translation ): qx , qy , qz = translation mesh [:, 0 ] += qx mesh [:, 1 ] += qy mesh [:, 2 ] += qz return mesh def rotate_mesh ( self , mesh : npt . ArrayLike , rotations : list ): \"\"\" Rotates mesh locations Parameters ---------- mesh : npt.ArrayLike shape n x 3 array holding x, y, z locations of each point rotations : list x, y, z axis rotation angles in degrees Returns ------- rotated_mesh : npt.ArrayLike shape n x 3 array holding x, y, z locations of each point \"\"\" gamma , beta , alpha = rotations rotation_matrix = Rotation . from_euler ( 'zyx' , [ alpha , beta , gamma ], degrees = True ) rotated_mesh = np . matmul ( rotation_matrix . as_matrix (), mesh . T ) . T return rotated_mesh def calculate_restoring_forces ( self ): \"\"\" calculates net forces and moments around the center of mass Returns ------- net_force : npt.ArrayLike Net force on center of mass. net_moments : npt.ArrayLike Net moments around center of mass. \"\"\" forces = self . force_value () net_force = np . sum ( forces , axis = 0 ) COM = self . find_center_of_mass () locations , _ = PS . x_v_current_3D moment_arms = self . translate_mesh ( locations , - COM ) moments = np . cross ( forces , moment_arms ) net_moments = np . sum ( moments , axis = 0 ) return net_force , net_moments class ParticleOpticalPropertyType ( Enum ): \"\"\" Enumeration representing the various types of optical properties for the Particles Attributes ---------- SPECULAR : str Indicates that the particle reflects light specularly ANISOTROPICSCATTERER : str Indicates that the particle scatter light anisotropically AXICONGRATING : str Indicates that the particle scatter light like a cone NOTE: Directing angle should be set in the format of a rotation matrix for the relevant particles that represents [rx, ry] rotations of area vector on property particle.axicon_angle \"\"\" SPECULAR = \"specular\" AXICONGRATING = \"axicongrating\" ANISOTROPICSCATTERER = \"anisotropicscatterer\" vectorized_optical_type_retriever = np . vectorize ( lambda p : p . optical_type ) if __name__ == \"__main__\" : from src.particleSystem.ParticleSystem import ParticleSystem from code_Validation.saddle_form import saddle_form from src.ExternalForces.LaserBeam import LaserBeam import matplotlib.pyplot as plt PS = saddle_form . instantiate_ps () #PS.stress_self() #for i in range(10): PS.simulate() for particle in PS . particles : particle . x [ 2 ] = 0 I_0 = 100e9 / ( 10 * 10 ) mu_x = 5 mu_y = 5 sigma = 5 LB = LaserBeam ( lambda x , y : I_0 * np . exp ( - 1 / 2 * (( x - mu_x ) / sigma ) ** 2 - 1 / 2 * (( y - mu_y ) / sigma ) ** 2 ), lambda x , y : [ 0 , 1 ]) LB = LaserBeam ( lambda x , y : np . ones ( x . shape ) * I_0 , lambda x , y : [ 0 , 1 ]) # One half of example will be 45 deg axicon angle directed towards (5,5) # other half will be specular reflection rots = [] for particle in PS . particles : particle . optical_type = ParticleOpticalPropertyType . SPECULAR if ( particle . x [ 0 ] - 5 ) ** 2 + ( particle . x [ 1 ] - 5 ) ** 2 >= 3 ** 2 : roty = 45 rotz = np . rad2deg ( np . arctan2 (( particle . x [ 1 ] - 5 ), ( particle . x [ 0 ] - 4.999 ))) particle . optical_type = ParticleOpticalPropertyType . AXICONGRATING #particle.axicon_angle = Rotation.from_euler('yz', [roty, rotz], degrees=True).as_matrix() particle . axicon_angle = Rotation . from_euler ( 'yz' , [ roty , rotz ], degrees = True ) . as_matrix () rots . append (( roty , rotz % 360 )) OFC = OpticalForceCalculator ( PS , LB ) forces = OFC . force_value () ax = PS . plot () points , _ = PS . x_v_current_3D x , y , z = points [:, 0 ], points [:, 1 ], points [:, 2 ] a_u = forces [:, 0 ] a_v = forces [:, 1 ] a_w = forces [:, 2 ] ax . scatter ( x , y , z ) ax . quiver ( x , y , z , a_u , a_v , a_w , length = 0.1 ) #ax2 = fig.add_subplot(projection='3d') #LB.plot(ax2, x_range = [0,10], y_range=[0,10]) Variables c vectorized_optical_type_retriever Classes OpticalForceCalculator class OpticalForceCalculator ( ParticleSystem , LaserBeam ) Handles the calculation of forces arising from optical pressure View Source class OpticalForceCalculator ( Force ) : \"\"\" Handles the calculation of forces arising from optical pressure \"\"\" def __init__ ( self , ParticleSystem , LaserBeam ) : self . ParticleSystem = ParticleSystem self . LaserBeam = LaserBeam if not hasattr ( self . ParticleSystem . particles [ 0 ] , 'optical_type' ) : raise AttributeError ( \"ParticleSystem does not have any optical properties set!\" ) super (). __init__ () return def __str__ ( self ) : print ( \"OpticalForceCalculator object instantiated with attributes:\" ) print ( f \"ParticleSystem: \\n {self.ParticleSystem}\" ) print ( f \"LaserBeam: \\n {self.LaserBeam}\" ) return \"\" def force_value ( self ) : PS = self . ParticleSystem LB = self . LaserBeam area_vectors = PS . find_surface () locations , _ = PS . x_v_current_3D forces = np . zeros ( locations . shape ) # adding index to locations for splitting and rejoining if not hasattr ( self , 'optical_type_mask' ) : self . create_optical_type_mask () # ! Note ! This bakes in implicitly that the orientation of the light # vector is in z + direction intensity_vectors = np . array ( [ [0,0,LB.intensity_profile(x,y) ] for x , y , z in locations ] ) for optical_type in self . optical_type_mask . keys () : if optical_type == ParticleOpticalPropertyType . SPECULAR : mask = self . optical_type_mask [ optical_type ] forces [ mask ] = self . calculate_specular_force ( area_vectors [ mask ] , intensity_vectors [ mask ] ) elif optical_type == ParticleOpticalPropertyType . AXICONGRATING : mask = self . optical_type_mask [ optical_type ] filtered_particles = compress ( PS . particles , mask ) axicon_angle = [ i.axicon_angle for i in filtered_particles ] forces [ mask ] = self . calculate_axicongrating_force ( area_vectors [ mask ] , intensity_vectors [ mask ] , axicon_angle ) return forces def calculate_specular_force ( self , area_vectors , intensity_vectors ) : abs_area_vectors = np . linalg . norm ( area_vectors , axis = 1 ) abs_intensity_vectors = intensity_vectors [ :,2 ] # assumes z + vector # The next operation divides by abs_intensity_vectors , which is undone later # this is to improve legibility because it is more analogous to the # cosine dot product rule cosine_factor = ( np . sum ( area_vectors * intensity_vectors , axis = 1 ) / ( abs_area_vectors * abs_intensity_vectors ) ) forces = area_vectors . copy () for i in range ( 3 ) : forces [ :,i ] *= abs_intensity_vectors * cosine_factor / c return forces def calculate_axicongrating_force ( self , area_vectors , intensity_vectors , axicon_angle ) : rotation_super_matrix = sp . linalg . block_diag ( * axicon_angle ) area_vectors = rotation_super_matrix . dot ( np . hstack ( area_vectors ). T ) area_vectors = np . reshape ( area_vectors , [ int(area_vectors.shape[0 ]/ 3 ), 3 ] ) abs_area_vectors = np . linalg . norm ( area_vectors , axis = 1 ) abs_intensity_vectors = intensity_vectors [ :,2 ] # assumes z + vector # The next operation divides by abs_intensity_vectors , which is undone later # this is to improve legibility because it is more analogous to the # cosine dot product rule cosine_factor = ( np . sum ( area_vectors * intensity_vectors , axis = 1 ) / ( abs_area_vectors * abs_intensity_vectors ) ) forces = area_vectors . copy () for i in range ( 3 ) : forces [ :,i ] *= abs_intensity_vectors * cosine_factor / c return forces def create_optical_type_mask ( self ) : \"\"\" loops over particles and sets a dict of masks onto self formatted as {type:mask} Raises ------ AttributeError Raises error when particles have no optical type set. \"\"\" optical_type_list = [] error_index_list = [] for i , particle in enumerate ( self . ParticleSystem . particles ) : if hasattr ( particle , 'optical_type' ) : optical_type_list . append ( particle . optical_type ) else : error_index_list . append ( i ) if len ( error_index_list ) > 0 : raise AttributeError ( \"All particles should have an optical type\" \" set prior to calculation of optical forces.\" \" Currently the particles with indices\" f \" {error_index_list} have no property set\" ) optical_type_list = np . array ( optical_type_list ) self . optical_type_mask = {} for optical_type in ParticleOpticalPropertyType : mask = optical_type_list == optical_type if sum ( mask ) > 0 : self . optical_type_mask [ optical_type ] = mask def calculate_stability_coefficients ( self , displacement_range = [ 0.1, 5 ] ) : \"\"\" Calculates the stability coefficients for the particle system Arguments --------- displacement_range : list list of length two representing the displacement magnitudes to perform the stability test. First value represents lateral displacement in meters. Second value represents tilt angle around the centre of mass in degrees. Returns ------- stability_matrix : npt.arraytype 6x6 matrix holding the stability terms of the system using notation convention of Jacobian \"\"\" q , alpha = displacement_range displacement_vectors = np . array ( [ [q,0,0,0,0,0 ] , [ 0,q,0,0,0,0 ] , [ 0,0,q,0,0,0 ] , [ 0,0,0,alpha,0,0 ] , [ 0,0,0,0,alpha,0 ] , [ 0,0,0,0,0,alpha ] ] ) jacobian = np . zeros (( 6 , 6 )) for i , vector in enumerate ( displacement_vectors ) : jacobian [ :,i ] = np . hstack ( self . calculate_force_gradient ( vector )) return jacobian def calculate_force_gradient ( self , displacement_vector : npt . ArrayLike ) : original = self . calculate_restoring_forces () self . displace_particle_system ( displacement_vector ) reaction = self . calculate_restoring_forces () self . un_displace_particle_system () displacement = displacement_vector [ displacement_vector !=0 ] if len ( displacement ) > 1 : raise AttributeError ( f \"Expected vector with only one nonzero value,\" \"instead got {displacement_vector}\" ) k_trans = ( reaction [ 0 ] - original [ 0 ] ) / displacement k_rot = ( reaction [ 1 ] - original [ 1 ] ) / displacement return k_trans , k_rot def displace_particle_system ( self , displacement : list ) : \"\"\" displaces the associated particle system with the prescribed amount around the center of mass. Arguments ---------- displacement_range : list list of length 6 representing the displacement magnitudes to perform the stability test. First three values represent lateral displacement in meters. Next three values represent tilt angle around the centre of mass in degrees. \"\"\" if len ( displacement ) != 6 : raise AttributeError ( \"Expected list of 6 arguments representing \" \"x,y,z,rx,ry,rz, got list of length {} instead\" . format ( len ( displacement ))) self . ParticleSystem . current_displacement = displacement qx , qy , qz , * _ = displacement COM = self . find_center_of_mass () locations , _ = PS . x_v_current_3D self . translate_mesh ( locations , - COM ) new_locations = self . rotate_mesh ( locations , displacement [ 3: ] ) new_locations = self . translate_mesh ( new_locations , displacement [ :3 ] ) new_locations = self . translate_mesh ( new_locations , COM ) for i , location in enumerate ( new_locations ) : # 'Unsafe' update needed to move fixed particles as well self . ParticleSystem . particles [ i ] . update_pos_unsafe ( location ) def un_displace_particle_system ( self ) : \"\"\" Reverses current mesh displacement of the associated particle system. \"\"\" if not hasattr ( self . ParticleSystem , 'current_displacement' ) : raise AttributeError ( \"Particle System is not currently displaced\" ) elif type ( self . ParticleSystem . current_displacement ) == type ( None ) : raise AttributeError ( \"Particle System is not currently displaced\" ) current_displacement = self . ParticleSystem . current_displacement reverse_displacement = - np . array ( current_displacement ) self . displace_particle_system ( reverse_displacement ) self . ParticleSystem . current_displacement = None def find_center_of_mass ( self ) : \"\"\" finds coordinates of center of mass of current mesh Returns ------- COM : npt.ArrayLike [x,y,z] vector of center of mass \"\"\" locations , _ = PS . x_v_current_3D COM = np . mean ( locations , axis = 0 ) return COM def translate_mesh ( self , mesh , translation ) : qx , qy , qz = translation mesh [ :,0 ] += qx mesh [ :,1 ] += qy mesh [ :,2 ] += qz return mesh def rotate_mesh ( self , mesh : npt . ArrayLike , rotations : list ) : \"\"\" Rotates mesh locations Parameters ---------- mesh : npt.ArrayLike shape n x 3 array holding x, y, z locations of each point rotations : list x, y, z axis rotation angles in degrees Returns ------- rotated_mesh : npt.ArrayLike shape n x 3 array holding x, y, z locations of each point \"\"\" gamma , beta , alpha = rotations rotation_matrix = Rotation . from_euler ( 'zyx' , [ alpha, beta, gamma ] , degrees = True ) rotated_mesh = np . matmul ( rotation_matrix . as_matrix (), mesh . T ). T return rotated_mesh def calculate_restoring_forces ( self ) : \"\"\" calculates net forces and moments around the center of mass Returns ------- net_force : npt.ArrayLike Net force on center of mass. net_moments : npt.ArrayLike Net moments around center of mass. \"\"\" forces = self . force_value () net_force = np . sum ( forces , axis = 0 ) COM = self . find_center_of_mass () locations , _ = PS . x_v_current_3D moment_arms = self . translate_mesh ( locations , - COM ) moments = np . cross ( forces , moment_arms ) net_moments = np . sum ( moments , axis = 0 ) return net_force , net_moments Ancestors (in MRO) src.particleSystem.Force.Force src.particleSystem.SystemObject.SystemObject abc.ABC Methods calculate_axicongrating_force def calculate_axicongrating_force ( self , area_vectors , intensity_vectors , axicon_angle ) View Source def calculate_axicongrating_force ( self , area_vectors , intensity_vectors , axicon_angle ) : rotation_super_matrix = sp . linalg . block_diag ( * axicon_angle ) area_vectors = rotation_super_matrix . dot ( np . hstack ( area_vectors ) . T ) area_vectors = np . reshape ( area_vectors , [ int ( area_vectors . shape [ 0 ] / 3 ) , 3 ] ) abs_area_vectors = np . linalg . norm ( area_vectors , axis = 1 ) abs_intensity_vectors = intensity_vectors [:, 2 ] # assumes z + vector # The next operation divides by abs_intensity_vectors , which is undone later # this is to improve legibility because it is more analogous to the # cosine dot product rule cosine_factor = ( np . sum ( area_vectors * intensity_vectors , axis = 1 ) / ( abs_area_vectors * abs_intensity_vectors ) ) forces = area_vectors . copy () for i in range ( 3 ) : forces [:, i ] *= abs_intensity_vectors * cosine_factor / c return forces calculate_force_gradient def calculate_force_gradient ( self , displacement_vector : Union [ numpy . __array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . __nested_sequence . _NestedSequence [ numpy . __array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . __nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) View Source def calculate_force_gradient ( self , displacement_vector : npt . ArrayLike ) : original = self . calculate_restoring_forces () self . displace_particle_system ( displacement_vector ) reaction = self . calculate_restoring_forces () self . un_displace_particle_system () displacement = displacement_vector [ displacement_vector != 0 ] if len ( displacement ) > 1 : raise AttributeError ( f \"Expected vector with only one nonzero value,\" \"instead got {displacement_vector}\" ) k_trans = ( reaction [ 0 ] - original [ 0 ] ) / displacement k_rot = ( reaction [ 1 ] - original [ 1 ] ) / displacement return k_trans , k_rot calculate_restoring_forces def calculate_restoring_forces ( self ) calculates net forces and moments around the center of mass Returns: Type Description npt.ArrayLike Net force on center of mass. View Source def calculate_restoring_forces ( self ) : \"\" \" calculates net forces and moments around the center of mass Returns ------- net_force : npt.ArrayLike Net force on center of mass. net_moments : npt.ArrayLike Net moments around center of mass. \"\" \" forces = self.force_value() net_force = np.sum(forces,axis=0) COM = self.find_center_of_mass() locations, _ = PS.x_v_current_3D moment_arms = self.translate_mesh(locations, -COM) moments = np.cross(forces, moment_arms) net_moments = np.sum(moments,axis=0) return net_force, net_moments calculate_specular_force def calculate_specular_force ( self , area_vectors , intensity_vectors ) View Source def calculate_specular_force ( self , area_vectors , intensity_vectors ) : abs_area_vectors = np . linalg . norm ( area_vectors , axis = 1 ) abs_intensity_vectors = intensity_vectors [:, 2 ] # assumes z + vector # The next operation divides by abs_intensity_vectors , which is undone later # this is to improve legibility because it is more analogous to the # cosine dot product rule cosine_factor = ( np . sum ( area_vectors * intensity_vectors , axis = 1 ) / ( abs_area_vectors * abs_intensity_vectors ) ) forces = area_vectors . copy () for i in range ( 3 ) : forces [:, i ] *= abs_intensity_vectors * cosine_factor / c return forces calculate_stability_coefficients def calculate_stability_coefficients ( self , displacement_range = [ 0.1 , 5 ] ) Calculates the stability coefficients for the particle system Parameters: Name Type Description Default displacement_range list list of length two representing the displacement magnitudes to perform the stability test. First value represents lateral displacement in meters. Second value represents tilt angle around the centre of mass in degrees. None Returns: Type Description npt.arraytype 6x6 matrix holding the stability terms of the system using notation convention of Jacobian View Source def calculate_stability_coefficients ( self , displacement_range = [ 0.1 , 5 ]): \"\"\" Calculates the stability coefficients for the particle system Arguments --------- displacement_range : list list of length two representing the displacement magnitudes to perform the stability test. First value represents lateral displacement in meters. Second value represents tilt angle around the centre of mass in degrees. Returns ------- stability_matrix : npt.arraytype 6x6 matrix holding the stability terms of the system using notation convention of Jacobian \"\"\" q , alpha = displacement_range displacement_vectors = np . array ([[ q , 0 , 0 , 0 , 0 , 0 ], [ 0 , q , 0 , 0 , 0 , 0 ], [ 0 , 0 , q , 0 , 0 , 0 ], [ 0 , 0 , 0 , alpha , 0 , 0 ], [ 0 , 0 , 0 , 0 , alpha , 0 ], [ 0 , 0 , 0 , 0 , 0 , alpha ]]) jacobian = np . zeros (( 6 , 6 )) for i , vector in enumerate ( displacement_vectors ): jacobian [:, i ] = np . hstack ( self . calculate_force_gradient ( vector )) return jacobian create_optical_type_mask def create_optical_type_mask ( self ) loops over particles and sets a dict of masks onto self formatted as {type:mask} Raises: Type Description AttributeError Raises error when particles have no optical type set. View Source def create_optical_type_mask ( self ) : \"\"\" loops over particles and sets a dict of masks onto self formatted as {type:mask} Raises ------ AttributeError Raises error when particles have no optical type set. \"\"\" optical_type_list = [] error_index_list = [] for i , particle in enumerate ( self . ParticleSystem . particles ) : if hasattr ( particle , 'optical_type' ) : optical_type_list . append ( particle . optical_type ) else : error_index_list . append ( i ) if len ( error_index_list ) > 0 : raise AttributeError ( \"All particles should have an optical type\" \" set prior to calculation of optical forces.\" \" Currently the particles with indices\" f \" {error_index_list} have no property set\" ) optical_type_list = np . array ( optical_type_list ) self . optical_type_mask = {} for optical_type in ParticleOpticalPropertyType : mask = optical_type_list == optical_type if sum ( mask ) > 0 : self . optical_type_mask [ optical_type ] = mask displace_particle_system def displace_particle_system ( self , displacement : list ) displaces the associated particle system with the prescribed amount around the center of mass. Arguments displacement_range : list list of length 6 representing the displacement magnitudes to perform the stability test. First three values represent lateral displacement in meters. Next three values represent tilt angle around the centre of mass in degrees. View Source def displace_particle_system ( self , displacement : list ) : \"\"\" displaces the associated particle system with the prescribed amount around the center of mass. Arguments ---------- displacement_range : list list of length 6 representing the displacement magnitudes to perform the stability test. First three values represent lateral displacement in meters. Next three values represent tilt angle around the centre of mass in degrees. \"\"\" if len ( displacement ) != 6 : raise AttributeError ( \"Expected list of 6 arguments representing \" \"x,y,z,rx,ry,rz, got list of length {} instead\" . format ( len ( displacement ))) self . ParticleSystem . current_displacement = displacement qx , qy , qz , * _ = displacement COM = self . find_center_of_mass () locations , _ = PS . x_v_current_3D self . translate_mesh ( locations , - COM ) new_locations = self . rotate_mesh ( locations , displacement [ 3: ] ) new_locations = self . translate_mesh ( new_locations , displacement [ :3 ] ) new_locations = self . translate_mesh ( new_locations , COM ) for i , location in enumerate ( new_locations ) : # 'Unsafe' update needed to move fixed particles as well self . ParticleSystem . particles [ i ] . update_pos_unsafe ( location ) find_center_of_mass def find_center_of_mass ( self ) finds coordinates of center of mass of current mesh Returns: Type Description npt.ArrayLike [x,y,z] vector of center of mass View Source def find_center_of_mass ( self ) : \"\" \" finds coordinates of center of mass of current mesh Returns ------- COM : npt.ArrayLike [x,y,z] vector of center of mass \"\" \" locations, _ = PS.x_v_current_3D COM = np.mean(locations,axis=0) return COM force_value def force_value ( self ) View Source def force_value ( self ) : PS = self . ParticleSystem LB = self . LaserBeam area_vectors = PS . find_surface () locations , _ = PS . x_v_current_3D forces = np . zeros ( locations . shape ) # adding index to locations for splitting and rejoining if not hasattr ( self , 'optical_type_mask' ) : self . create_optical_type_mask () # ! Note ! This bakes in implicitly that the orientation of the light # vector is in z + direction intensity_vectors = np . array ( [ [0,0,LB.intensity_profile(x,y) ] for x , y , z in locations ] ) for optical_type in self . optical_type_mask . keys () : if optical_type == ParticleOpticalPropertyType . SPECULAR : mask = self . optical_type_mask [ optical_type ] forces [ mask ] = self . calculate_specular_force ( area_vectors [ mask ] , intensity_vectors [ mask ] ) elif optical_type == ParticleOpticalPropertyType . AXICONGRATING : mask = self . optical_type_mask [ optical_type ] filtered_particles = compress ( PS . particles , mask ) axicon_angle = [ i.axicon_angle for i in filtered_particles ] forces [ mask ] = self . calculate_axicongrating_force ( area_vectors [ mask ] , intensity_vectors [ mask ] , axicon_angle ) return forces rotate_mesh def rotate_mesh ( self , mesh : Union [ numpy . __array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . __nested_sequence . _NestedSequence [ numpy . __array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . __nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], rotations : list ) Rotates mesh locations Parameters: Name Type Description Default mesh npt.ArrayLike shape n x 3 array holding x, y, z locations of each point None rotations list x, y, z axis rotation angles in degrees None Returns: Type Description npt.ArrayLike shape n x 3 array holding x, y, z locations of each point View Source def rotate_mesh ( self , mesh : npt . ArrayLike , rotations : list ) : \"\" \" Rotates mesh locations Parameters ---------- mesh : npt.ArrayLike shape n x 3 array holding x, y, z locations of each point rotations : list x, y, z axis rotation angles in degrees Returns ------- rotated_mesh : npt.ArrayLike shape n x 3 array holding x, y, z locations of each point \"\" \" gamma, beta, alpha = rotations rotation_matrix = Rotation.from_euler('zyx', [alpha, beta, gamma], degrees=True) rotated_mesh = np.matmul(rotation_matrix.as_matrix(), mesh.T).T return rotated_mesh translate_mesh def translate_mesh ( self , mesh , translation ) View Source def translate_mesh ( self , mesh , translation ) : qx , qy , qz = translation mesh [:, 0 ] += qx mesh [:, 1 ] += qy mesh [:, 2 ] += qz return mesh un_displace_particle_system def un_displace_particle_system ( self ) Reverses current mesh displacement of the associated particle system. View Source def un_displace_particle_system ( self ): \"\"\" Reverses current mesh displacement of the associated particle system. \"\"\" if not hasattr ( self . ParticleSystem , ' current_displacement ' ): raise AttributeError ( \"Particle System is not currently displaced\" ) elif type ( self . ParticleSystem . current_displacement ) == type ( None ): raise AttributeError ( \"Particle System is not currently displaced\" ) current_displacement = self . ParticleSystem . current_displacement reverse_displacement = - np . array ( current_displacement ) self . displace_particle_system ( reverse_displacement ) self . ParticleSystem . current_displacement = None ParticleOpticalPropertyType class ParticleOpticalPropertyType ( / , * args , ** kwargs ) Enumeration representing the various types of optical properties for the Particles Attributes Name Type Description Default SPECULAR str Indicates that the particle reflects light specularly None ANISOTROPICSCATTERER str Indicates that the particle scatter light anisotropically None AXICONGRATING str Indicates that the particle scatter light like a cone NOTE: Directing angle should be set in the format of a rotation matrix for the relevant particles that represents [rx, ry] rotations of area vector on property particle.axicon_angle None View Source class ParticleOpticalPropertyType ( Enum ): \"\"\" Enumeration representing the various types of optical properties for the Particles Attributes ---------- SPECULAR : str Indicates that the particle reflects light specularly ANISOTROPICSCATTERER : str Indicates that the particle scatter light anisotropically AXICONGRATING : str Indicates that the particle scatter light like a cone NOTE: Directing angle should be set in the format of a rotation matrix for the relevant particles that represents [rx, ry] rotations of area vector on property particle.axicon_angle \"\"\" SPECULAR = \"specular\" AXICONGRATING = \"axicongrating\" ANISOTROPICSCATTERER = \"anisotropicscatterer\" Ancestors (in MRO) enum.Enum Class variables ANISOTROPICSCATTERER AXICONGRATING SPECULAR name value","title":"Opticalforcecalculator"},{"location":"reference/src/ExternalForces/OpticalForceCalculator/#module-srcexternalforcesopticalforcecalculator","text":"Optical force calculation framework Created on Tue Nov 7 14:19:21 2023 View Source # -*- coding: utf-8 -*- \"\"\" Optical force calculation framework Created on Tue Nov 7 14:19:21 2023 @author: Mark Kalsbeek \"\"\" from enum import Enum from itertools import compress import numpy as np import numpy.typing as npt import scipy as sp from scipy.constants import c from scipy.spatial.transform import Rotation from src.particleSystem.Force import Force import logging class OpticalForceCalculator ( Force ): \"\"\" Handles the calculation of forces arising from optical pressure \"\"\" def __init__ ( self , ParticleSystem , LaserBeam ): self . ParticleSystem = ParticleSystem self . LaserBeam = LaserBeam if not hasattr ( self . ParticleSystem . particles [ 0 ], 'optical_type' ): raise AttributeError ( \"ParticleSystem does not have any optical properties set!\" ) super () . __init__ () return def __str__ ( self ): print ( \"OpticalForceCalculator object instantiated with attributes:\" ) print ( f \"ParticleSystem: \\n { self . ParticleSystem } \" ) print ( f \"LaserBeam: \\n { self . LaserBeam } \" ) return \"\" def force_value ( self ): PS = self . ParticleSystem LB = self . LaserBeam area_vectors = PS . find_surface () locations , _ = PS . x_v_current_3D forces = np . zeros ( locations . shape ) # adding index to locations for splitting and rejoining if not hasattr ( self , 'optical_type_mask' ): self . create_optical_type_mask () # ! Note ! This bakes in implicitly that the orientation of the light # vector is in z+ direction intensity_vectors = np . array ([[ 0 , 0 , LB . intensity_profile ( x , y )] for x , y , z in locations ]) for optical_type in self . optical_type_mask . keys (): if optical_type == ParticleOpticalPropertyType . SPECULAR : mask = self . optical_type_mask [ optical_type ] forces [ mask ] = self . calculate_specular_force ( area_vectors [ mask ], intensity_vectors [ mask ]) elif optical_type == ParticleOpticalPropertyType . AXICONGRATING : mask = self . optical_type_mask [ optical_type ] filtered_particles = compress ( PS . particles , mask ) axicon_angle = [ i . axicon_angle for i in filtered_particles ] forces [ mask ] = self . calculate_axicongrating_force ( area_vectors [ mask ], intensity_vectors [ mask ], axicon_angle ) return forces def calculate_specular_force ( self , area_vectors , intensity_vectors ): abs_area_vectors = np . linalg . norm ( area_vectors , axis = 1 ) abs_intensity_vectors = intensity_vectors [:, 2 ] # assumes z+ vector # The next operation divides by abs_intensity_vectors, which is undone later # this is to improve legibility because it is more analogous to the # cosine dot product rule cosine_factor = ( np . sum ( area_vectors * intensity_vectors , axis = 1 ) / ( abs_area_vectors * abs_intensity_vectors ) ) forces = area_vectors . copy () for i in range ( 3 ): forces [:, i ] *= abs_intensity_vectors * cosine_factor / c return forces def calculate_axicongrating_force ( self , area_vectors , intensity_vectors , axicon_angle ): rotation_super_matrix = sp . linalg . block_diag ( * axicon_angle ) area_vectors = rotation_super_matrix . dot ( np . hstack ( area_vectors ) . T ) area_vectors = np . reshape ( area_vectors , [ int ( area_vectors . shape [ 0 ] / 3 ), 3 ]) abs_area_vectors = np . linalg . norm ( area_vectors , axis = 1 ) abs_intensity_vectors = intensity_vectors [:, 2 ] # assumes z+ vector # The next operation divides by abs_intensity_vectors, which is undone later # this is to improve legibility because it is more analogous to the # cosine dot product rule cosine_factor = ( np . sum ( area_vectors * intensity_vectors , axis = 1 ) / ( abs_area_vectors * abs_intensity_vectors ) ) forces = area_vectors . copy () for i in range ( 3 ): forces [:, i ] *= abs_intensity_vectors * cosine_factor / c return forces def create_optical_type_mask ( self ): \"\"\" loops over particles and sets a dict of masks onto self formatted as {type:mask} Raises ------ AttributeError Raises error when particles have no optical type set. \"\"\" optical_type_list = [] error_index_list = [] for i , particle in enumerate ( self . ParticleSystem . particles ): if hasattr ( particle , 'optical_type' ): optical_type_list . append ( particle . optical_type ) else : error_index_list . append ( i ) if len ( error_index_list ) > 0 : raise AttributeError ( \"All particles should have an optical type\" \" set prior to calculation of optical forces.\" \" Currently the particles with indices\" f \" { error_index_list } have no property set\" ) optical_type_list = np . array ( optical_type_list ) self . optical_type_mask = {} for optical_type in ParticleOpticalPropertyType : mask = optical_type_list == optical_type if sum ( mask ) > 0 : self . optical_type_mask [ optical_type ] = mask def calculate_stability_coefficients ( self , displacement_range = [ 0.1 , 5 ]): \"\"\" Calculates the stability coefficients for the particle system Arguments --------- displacement_range : list list of length two representing the displacement magnitudes to perform the stability test. First value represents lateral displacement in meters. Second value represents tilt angle around the centre of mass in degrees. Returns ------- stability_matrix : npt.arraytype 6x6 matrix holding the stability terms of the system using notation convention of Jacobian \"\"\" q , alpha = displacement_range displacement_vectors = np . array ([[ q , 0 , 0 , 0 , 0 , 0 ], [ 0 , q , 0 , 0 , 0 , 0 ], [ 0 , 0 , q , 0 , 0 , 0 ], [ 0 , 0 , 0 , alpha , 0 , 0 ], [ 0 , 0 , 0 , 0 , alpha , 0 ], [ 0 , 0 , 0 , 0 , 0 , alpha ]]) jacobian = np . zeros (( 6 , 6 )) for i , vector in enumerate ( displacement_vectors ): jacobian [:, i ] = np . hstack ( self . calculate_force_gradient ( vector )) return jacobian def calculate_force_gradient ( self , displacement_vector : npt . ArrayLike ): original = self . calculate_restoring_forces () self . displace_particle_system ( displacement_vector ) reaction = self . calculate_restoring_forces () self . un_displace_particle_system () displacement = displacement_vector [ displacement_vector != 0 ] if len ( displacement ) > 1 : raise AttributeError ( f \"Expected vector with only one nonzero value,\" \"instead got {displacement_vector} \" ) k_trans = ( reaction [ 0 ] - original [ 0 ]) / displacement k_rot = ( reaction [ 1 ] - original [ 1 ]) / displacement return k_trans , k_rot def displace_particle_system ( self , displacement : list ): \"\"\" displaces the associated particle system with the prescribed amount around the center of mass. Arguments ---------- displacement_range : list list of length 6 representing the displacement magnitudes to perform the stability test. First three values represent lateral displacement in meters. Next three values represent tilt angle around the centre of mass in degrees. \"\"\" if len ( displacement ) != 6 : raise AttributeError ( \"Expected list of 6 arguments representing \" \"x,y,z,rx,ry,rz, got list of length {} instead\" . format ( len ( displacement ))) self . ParticleSystem . current_displacement = displacement qx , qy , qz , * _ = displacement COM = self . find_center_of_mass () locations , _ = PS . x_v_current_3D self . translate_mesh ( locations , - COM ) new_locations = self . rotate_mesh ( locations , displacement [ 3 :]) new_locations = self . translate_mesh ( new_locations , displacement [: 3 ]) new_locations = self . translate_mesh ( new_locations , COM ) for i , location in enumerate ( new_locations ): # 'Unsafe' update needed to move fixed particles as well self . ParticleSystem . particles [ i ] . update_pos_unsafe ( location ) def un_displace_particle_system ( self ): \"\"\" Reverses current mesh displacement of the associated particle system. \"\"\" if not hasattr ( self . ParticleSystem , 'current_displacement' ): raise AttributeError ( \"Particle System is not currently displaced\" ) elif type ( self . ParticleSystem . current_displacement ) == type ( None ): raise AttributeError ( \"Particle System is not currently displaced\" ) current_displacement = self . ParticleSystem . current_displacement reverse_displacement = - np . array ( current_displacement ) self . displace_particle_system ( reverse_displacement ) self . ParticleSystem . current_displacement = None def find_center_of_mass ( self ): \"\"\" finds coordinates of center of mass of current mesh Returns ------- COM : npt.ArrayLike [x,y,z] vector of center of mass \"\"\" locations , _ = PS . x_v_current_3D COM = np . mean ( locations , axis = 0 ) return COM def translate_mesh ( self , mesh , translation ): qx , qy , qz = translation mesh [:, 0 ] += qx mesh [:, 1 ] += qy mesh [:, 2 ] += qz return mesh def rotate_mesh ( self , mesh : npt . ArrayLike , rotations : list ): \"\"\" Rotates mesh locations Parameters ---------- mesh : npt.ArrayLike shape n x 3 array holding x, y, z locations of each point rotations : list x, y, z axis rotation angles in degrees Returns ------- rotated_mesh : npt.ArrayLike shape n x 3 array holding x, y, z locations of each point \"\"\" gamma , beta , alpha = rotations rotation_matrix = Rotation . from_euler ( 'zyx' , [ alpha , beta , gamma ], degrees = True ) rotated_mesh = np . matmul ( rotation_matrix . as_matrix (), mesh . T ) . T return rotated_mesh def calculate_restoring_forces ( self ): \"\"\" calculates net forces and moments around the center of mass Returns ------- net_force : npt.ArrayLike Net force on center of mass. net_moments : npt.ArrayLike Net moments around center of mass. \"\"\" forces = self . force_value () net_force = np . sum ( forces , axis = 0 ) COM = self . find_center_of_mass () locations , _ = PS . x_v_current_3D moment_arms = self . translate_mesh ( locations , - COM ) moments = np . cross ( forces , moment_arms ) net_moments = np . sum ( moments , axis = 0 ) return net_force , net_moments class ParticleOpticalPropertyType ( Enum ): \"\"\" Enumeration representing the various types of optical properties for the Particles Attributes ---------- SPECULAR : str Indicates that the particle reflects light specularly ANISOTROPICSCATTERER : str Indicates that the particle scatter light anisotropically AXICONGRATING : str Indicates that the particle scatter light like a cone NOTE: Directing angle should be set in the format of a rotation matrix for the relevant particles that represents [rx, ry] rotations of area vector on property particle.axicon_angle \"\"\" SPECULAR = \"specular\" AXICONGRATING = \"axicongrating\" ANISOTROPICSCATTERER = \"anisotropicscatterer\" vectorized_optical_type_retriever = np . vectorize ( lambda p : p . optical_type ) if __name__ == \"__main__\" : from src.particleSystem.ParticleSystem import ParticleSystem from code_Validation.saddle_form import saddle_form from src.ExternalForces.LaserBeam import LaserBeam import matplotlib.pyplot as plt PS = saddle_form . instantiate_ps () #PS.stress_self() #for i in range(10): PS.simulate() for particle in PS . particles : particle . x [ 2 ] = 0 I_0 = 100e9 / ( 10 * 10 ) mu_x = 5 mu_y = 5 sigma = 5 LB = LaserBeam ( lambda x , y : I_0 * np . exp ( - 1 / 2 * (( x - mu_x ) / sigma ) ** 2 - 1 / 2 * (( y - mu_y ) / sigma ) ** 2 ), lambda x , y : [ 0 , 1 ]) LB = LaserBeam ( lambda x , y : np . ones ( x . shape ) * I_0 , lambda x , y : [ 0 , 1 ]) # One half of example will be 45 deg axicon angle directed towards (5,5) # other half will be specular reflection rots = [] for particle in PS . particles : particle . optical_type = ParticleOpticalPropertyType . SPECULAR if ( particle . x [ 0 ] - 5 ) ** 2 + ( particle . x [ 1 ] - 5 ) ** 2 >= 3 ** 2 : roty = 45 rotz = np . rad2deg ( np . arctan2 (( particle . x [ 1 ] - 5 ), ( particle . x [ 0 ] - 4.999 ))) particle . optical_type = ParticleOpticalPropertyType . AXICONGRATING #particle.axicon_angle = Rotation.from_euler('yz', [roty, rotz], degrees=True).as_matrix() particle . axicon_angle = Rotation . from_euler ( 'yz' , [ roty , rotz ], degrees = True ) . as_matrix () rots . append (( roty , rotz % 360 )) OFC = OpticalForceCalculator ( PS , LB ) forces = OFC . force_value () ax = PS . plot () points , _ = PS . x_v_current_3D x , y , z = points [:, 0 ], points [:, 1 ], points [:, 2 ] a_u = forces [:, 0 ] a_v = forces [:, 1 ] a_w = forces [:, 2 ] ax . scatter ( x , y , z ) ax . quiver ( x , y , z , a_u , a_v , a_w , length = 0.1 ) #ax2 = fig.add_subplot(projection='3d') #LB.plot(ax2, x_range = [0,10], y_range=[0,10])","title":"Module src.ExternalForces.OpticalForceCalculator"},{"location":"reference/src/ExternalForces/OpticalForceCalculator/#variables","text":"c vectorized_optical_type_retriever","title":"Variables"},{"location":"reference/src/ExternalForces/OpticalForceCalculator/#classes","text":"","title":"Classes"},{"location":"reference/src/ExternalForces/OpticalForceCalculator/#opticalforcecalculator","text":"class OpticalForceCalculator ( ParticleSystem , LaserBeam ) Handles the calculation of forces arising from optical pressure View Source class OpticalForceCalculator ( Force ) : \"\"\" Handles the calculation of forces arising from optical pressure \"\"\" def __init__ ( self , ParticleSystem , LaserBeam ) : self . ParticleSystem = ParticleSystem self . LaserBeam = LaserBeam if not hasattr ( self . ParticleSystem . particles [ 0 ] , 'optical_type' ) : raise AttributeError ( \"ParticleSystem does not have any optical properties set!\" ) super (). __init__ () return def __str__ ( self ) : print ( \"OpticalForceCalculator object instantiated with attributes:\" ) print ( f \"ParticleSystem: \\n {self.ParticleSystem}\" ) print ( f \"LaserBeam: \\n {self.LaserBeam}\" ) return \"\" def force_value ( self ) : PS = self . ParticleSystem LB = self . LaserBeam area_vectors = PS . find_surface () locations , _ = PS . x_v_current_3D forces = np . zeros ( locations . shape ) # adding index to locations for splitting and rejoining if not hasattr ( self , 'optical_type_mask' ) : self . create_optical_type_mask () # ! Note ! This bakes in implicitly that the orientation of the light # vector is in z + direction intensity_vectors = np . array ( [ [0,0,LB.intensity_profile(x,y) ] for x , y , z in locations ] ) for optical_type in self . optical_type_mask . keys () : if optical_type == ParticleOpticalPropertyType . SPECULAR : mask = self . optical_type_mask [ optical_type ] forces [ mask ] = self . calculate_specular_force ( area_vectors [ mask ] , intensity_vectors [ mask ] ) elif optical_type == ParticleOpticalPropertyType . AXICONGRATING : mask = self . optical_type_mask [ optical_type ] filtered_particles = compress ( PS . particles , mask ) axicon_angle = [ i.axicon_angle for i in filtered_particles ] forces [ mask ] = self . calculate_axicongrating_force ( area_vectors [ mask ] , intensity_vectors [ mask ] , axicon_angle ) return forces def calculate_specular_force ( self , area_vectors , intensity_vectors ) : abs_area_vectors = np . linalg . norm ( area_vectors , axis = 1 ) abs_intensity_vectors = intensity_vectors [ :,2 ] # assumes z + vector # The next operation divides by abs_intensity_vectors , which is undone later # this is to improve legibility because it is more analogous to the # cosine dot product rule cosine_factor = ( np . sum ( area_vectors * intensity_vectors , axis = 1 ) / ( abs_area_vectors * abs_intensity_vectors ) ) forces = area_vectors . copy () for i in range ( 3 ) : forces [ :,i ] *= abs_intensity_vectors * cosine_factor / c return forces def calculate_axicongrating_force ( self , area_vectors , intensity_vectors , axicon_angle ) : rotation_super_matrix = sp . linalg . block_diag ( * axicon_angle ) area_vectors = rotation_super_matrix . dot ( np . hstack ( area_vectors ). T ) area_vectors = np . reshape ( area_vectors , [ int(area_vectors.shape[0 ]/ 3 ), 3 ] ) abs_area_vectors = np . linalg . norm ( area_vectors , axis = 1 ) abs_intensity_vectors = intensity_vectors [ :,2 ] # assumes z + vector # The next operation divides by abs_intensity_vectors , which is undone later # this is to improve legibility because it is more analogous to the # cosine dot product rule cosine_factor = ( np . sum ( area_vectors * intensity_vectors , axis = 1 ) / ( abs_area_vectors * abs_intensity_vectors ) ) forces = area_vectors . copy () for i in range ( 3 ) : forces [ :,i ] *= abs_intensity_vectors * cosine_factor / c return forces def create_optical_type_mask ( self ) : \"\"\" loops over particles and sets a dict of masks onto self formatted as {type:mask} Raises ------ AttributeError Raises error when particles have no optical type set. \"\"\" optical_type_list = [] error_index_list = [] for i , particle in enumerate ( self . ParticleSystem . particles ) : if hasattr ( particle , 'optical_type' ) : optical_type_list . append ( particle . optical_type ) else : error_index_list . append ( i ) if len ( error_index_list ) > 0 : raise AttributeError ( \"All particles should have an optical type\" \" set prior to calculation of optical forces.\" \" Currently the particles with indices\" f \" {error_index_list} have no property set\" ) optical_type_list = np . array ( optical_type_list ) self . optical_type_mask = {} for optical_type in ParticleOpticalPropertyType : mask = optical_type_list == optical_type if sum ( mask ) > 0 : self . optical_type_mask [ optical_type ] = mask def calculate_stability_coefficients ( self , displacement_range = [ 0.1, 5 ] ) : \"\"\" Calculates the stability coefficients for the particle system Arguments --------- displacement_range : list list of length two representing the displacement magnitudes to perform the stability test. First value represents lateral displacement in meters. Second value represents tilt angle around the centre of mass in degrees. Returns ------- stability_matrix : npt.arraytype 6x6 matrix holding the stability terms of the system using notation convention of Jacobian \"\"\" q , alpha = displacement_range displacement_vectors = np . array ( [ [q,0,0,0,0,0 ] , [ 0,q,0,0,0,0 ] , [ 0,0,q,0,0,0 ] , [ 0,0,0,alpha,0,0 ] , [ 0,0,0,0,alpha,0 ] , [ 0,0,0,0,0,alpha ] ] ) jacobian = np . zeros (( 6 , 6 )) for i , vector in enumerate ( displacement_vectors ) : jacobian [ :,i ] = np . hstack ( self . calculate_force_gradient ( vector )) return jacobian def calculate_force_gradient ( self , displacement_vector : npt . ArrayLike ) : original = self . calculate_restoring_forces () self . displace_particle_system ( displacement_vector ) reaction = self . calculate_restoring_forces () self . un_displace_particle_system () displacement = displacement_vector [ displacement_vector !=0 ] if len ( displacement ) > 1 : raise AttributeError ( f \"Expected vector with only one nonzero value,\" \"instead got {displacement_vector}\" ) k_trans = ( reaction [ 0 ] - original [ 0 ] ) / displacement k_rot = ( reaction [ 1 ] - original [ 1 ] ) / displacement return k_trans , k_rot def displace_particle_system ( self , displacement : list ) : \"\"\" displaces the associated particle system with the prescribed amount around the center of mass. Arguments ---------- displacement_range : list list of length 6 representing the displacement magnitudes to perform the stability test. First three values represent lateral displacement in meters. Next three values represent tilt angle around the centre of mass in degrees. \"\"\" if len ( displacement ) != 6 : raise AttributeError ( \"Expected list of 6 arguments representing \" \"x,y,z,rx,ry,rz, got list of length {} instead\" . format ( len ( displacement ))) self . ParticleSystem . current_displacement = displacement qx , qy , qz , * _ = displacement COM = self . find_center_of_mass () locations , _ = PS . x_v_current_3D self . translate_mesh ( locations , - COM ) new_locations = self . rotate_mesh ( locations , displacement [ 3: ] ) new_locations = self . translate_mesh ( new_locations , displacement [ :3 ] ) new_locations = self . translate_mesh ( new_locations , COM ) for i , location in enumerate ( new_locations ) : # 'Unsafe' update needed to move fixed particles as well self . ParticleSystem . particles [ i ] . update_pos_unsafe ( location ) def un_displace_particle_system ( self ) : \"\"\" Reverses current mesh displacement of the associated particle system. \"\"\" if not hasattr ( self . ParticleSystem , 'current_displacement' ) : raise AttributeError ( \"Particle System is not currently displaced\" ) elif type ( self . ParticleSystem . current_displacement ) == type ( None ) : raise AttributeError ( \"Particle System is not currently displaced\" ) current_displacement = self . ParticleSystem . current_displacement reverse_displacement = - np . array ( current_displacement ) self . displace_particle_system ( reverse_displacement ) self . ParticleSystem . current_displacement = None def find_center_of_mass ( self ) : \"\"\" finds coordinates of center of mass of current mesh Returns ------- COM : npt.ArrayLike [x,y,z] vector of center of mass \"\"\" locations , _ = PS . x_v_current_3D COM = np . mean ( locations , axis = 0 ) return COM def translate_mesh ( self , mesh , translation ) : qx , qy , qz = translation mesh [ :,0 ] += qx mesh [ :,1 ] += qy mesh [ :,2 ] += qz return mesh def rotate_mesh ( self , mesh : npt . ArrayLike , rotations : list ) : \"\"\" Rotates mesh locations Parameters ---------- mesh : npt.ArrayLike shape n x 3 array holding x, y, z locations of each point rotations : list x, y, z axis rotation angles in degrees Returns ------- rotated_mesh : npt.ArrayLike shape n x 3 array holding x, y, z locations of each point \"\"\" gamma , beta , alpha = rotations rotation_matrix = Rotation . from_euler ( 'zyx' , [ alpha, beta, gamma ] , degrees = True ) rotated_mesh = np . matmul ( rotation_matrix . as_matrix (), mesh . T ). T return rotated_mesh def calculate_restoring_forces ( self ) : \"\"\" calculates net forces and moments around the center of mass Returns ------- net_force : npt.ArrayLike Net force on center of mass. net_moments : npt.ArrayLike Net moments around center of mass. \"\"\" forces = self . force_value () net_force = np . sum ( forces , axis = 0 ) COM = self . find_center_of_mass () locations , _ = PS . x_v_current_3D moment_arms = self . translate_mesh ( locations , - COM ) moments = np . cross ( forces , moment_arms ) net_moments = np . sum ( moments , axis = 0 ) return net_force , net_moments","title":"OpticalForceCalculator"},{"location":"reference/src/ExternalForces/OpticalForceCalculator/#ancestors-in-mro","text":"src.particleSystem.Force.Force src.particleSystem.SystemObject.SystemObject abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/src/ExternalForces/OpticalForceCalculator/#methods","text":"","title":"Methods"},{"location":"reference/src/ExternalForces/OpticalForceCalculator/#calculate_axicongrating_force","text":"def calculate_axicongrating_force ( self , area_vectors , intensity_vectors , axicon_angle ) View Source def calculate_axicongrating_force ( self , area_vectors , intensity_vectors , axicon_angle ) : rotation_super_matrix = sp . linalg . block_diag ( * axicon_angle ) area_vectors = rotation_super_matrix . dot ( np . hstack ( area_vectors ) . T ) area_vectors = np . reshape ( area_vectors , [ int ( area_vectors . shape [ 0 ] / 3 ) , 3 ] ) abs_area_vectors = np . linalg . norm ( area_vectors , axis = 1 ) abs_intensity_vectors = intensity_vectors [:, 2 ] # assumes z + vector # The next operation divides by abs_intensity_vectors , which is undone later # this is to improve legibility because it is more analogous to the # cosine dot product rule cosine_factor = ( np . sum ( area_vectors * intensity_vectors , axis = 1 ) / ( abs_area_vectors * abs_intensity_vectors ) ) forces = area_vectors . copy () for i in range ( 3 ) : forces [:, i ] *= abs_intensity_vectors * cosine_factor / c return forces","title":"calculate_axicongrating_force"},{"location":"reference/src/ExternalForces/OpticalForceCalculator/#calculate_force_gradient","text":"def calculate_force_gradient ( self , displacement_vector : Union [ numpy . __array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . __nested_sequence . _NestedSequence [ numpy . __array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . __nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) View Source def calculate_force_gradient ( self , displacement_vector : npt . ArrayLike ) : original = self . calculate_restoring_forces () self . displace_particle_system ( displacement_vector ) reaction = self . calculate_restoring_forces () self . un_displace_particle_system () displacement = displacement_vector [ displacement_vector != 0 ] if len ( displacement ) > 1 : raise AttributeError ( f \"Expected vector with only one nonzero value,\" \"instead got {displacement_vector}\" ) k_trans = ( reaction [ 0 ] - original [ 0 ] ) / displacement k_rot = ( reaction [ 1 ] - original [ 1 ] ) / displacement return k_trans , k_rot","title":"calculate_force_gradient"},{"location":"reference/src/ExternalForces/OpticalForceCalculator/#calculate_restoring_forces","text":"def calculate_restoring_forces ( self ) calculates net forces and moments around the center of mass Returns: Type Description npt.ArrayLike Net force on center of mass. View Source def calculate_restoring_forces ( self ) : \"\" \" calculates net forces and moments around the center of mass Returns ------- net_force : npt.ArrayLike Net force on center of mass. net_moments : npt.ArrayLike Net moments around center of mass. \"\" \" forces = self.force_value() net_force = np.sum(forces,axis=0) COM = self.find_center_of_mass() locations, _ = PS.x_v_current_3D moment_arms = self.translate_mesh(locations, -COM) moments = np.cross(forces, moment_arms) net_moments = np.sum(moments,axis=0) return net_force, net_moments","title":"calculate_restoring_forces"},{"location":"reference/src/ExternalForces/OpticalForceCalculator/#calculate_specular_force","text":"def calculate_specular_force ( self , area_vectors , intensity_vectors ) View Source def calculate_specular_force ( self , area_vectors , intensity_vectors ) : abs_area_vectors = np . linalg . norm ( area_vectors , axis = 1 ) abs_intensity_vectors = intensity_vectors [:, 2 ] # assumes z + vector # The next operation divides by abs_intensity_vectors , which is undone later # this is to improve legibility because it is more analogous to the # cosine dot product rule cosine_factor = ( np . sum ( area_vectors * intensity_vectors , axis = 1 ) / ( abs_area_vectors * abs_intensity_vectors ) ) forces = area_vectors . copy () for i in range ( 3 ) : forces [:, i ] *= abs_intensity_vectors * cosine_factor / c return forces","title":"calculate_specular_force"},{"location":"reference/src/ExternalForces/OpticalForceCalculator/#calculate_stability_coefficients","text":"def calculate_stability_coefficients ( self , displacement_range = [ 0.1 , 5 ] ) Calculates the stability coefficients for the particle system Parameters: Name Type Description Default displacement_range list list of length two representing the displacement magnitudes to perform the stability test. First value represents lateral displacement in meters. Second value represents tilt angle around the centre of mass in degrees. None Returns: Type Description npt.arraytype 6x6 matrix holding the stability terms of the system using notation convention of Jacobian View Source def calculate_stability_coefficients ( self , displacement_range = [ 0.1 , 5 ]): \"\"\" Calculates the stability coefficients for the particle system Arguments --------- displacement_range : list list of length two representing the displacement magnitudes to perform the stability test. First value represents lateral displacement in meters. Second value represents tilt angle around the centre of mass in degrees. Returns ------- stability_matrix : npt.arraytype 6x6 matrix holding the stability terms of the system using notation convention of Jacobian \"\"\" q , alpha = displacement_range displacement_vectors = np . array ([[ q , 0 , 0 , 0 , 0 , 0 ], [ 0 , q , 0 , 0 , 0 , 0 ], [ 0 , 0 , q , 0 , 0 , 0 ], [ 0 , 0 , 0 , alpha , 0 , 0 ], [ 0 , 0 , 0 , 0 , alpha , 0 ], [ 0 , 0 , 0 , 0 , 0 , alpha ]]) jacobian = np . zeros (( 6 , 6 )) for i , vector in enumerate ( displacement_vectors ): jacobian [:, i ] = np . hstack ( self . calculate_force_gradient ( vector )) return jacobian","title":"calculate_stability_coefficients"},{"location":"reference/src/ExternalForces/OpticalForceCalculator/#create_optical_type_mask","text":"def create_optical_type_mask ( self ) loops over particles and sets a dict of masks onto self formatted as {type:mask} Raises: Type Description AttributeError Raises error when particles have no optical type set. View Source def create_optical_type_mask ( self ) : \"\"\" loops over particles and sets a dict of masks onto self formatted as {type:mask} Raises ------ AttributeError Raises error when particles have no optical type set. \"\"\" optical_type_list = [] error_index_list = [] for i , particle in enumerate ( self . ParticleSystem . particles ) : if hasattr ( particle , 'optical_type' ) : optical_type_list . append ( particle . optical_type ) else : error_index_list . append ( i ) if len ( error_index_list ) > 0 : raise AttributeError ( \"All particles should have an optical type\" \" set prior to calculation of optical forces.\" \" Currently the particles with indices\" f \" {error_index_list} have no property set\" ) optical_type_list = np . array ( optical_type_list ) self . optical_type_mask = {} for optical_type in ParticleOpticalPropertyType : mask = optical_type_list == optical_type if sum ( mask ) > 0 : self . optical_type_mask [ optical_type ] = mask","title":"create_optical_type_mask"},{"location":"reference/src/ExternalForces/OpticalForceCalculator/#displace_particle_system","text":"def displace_particle_system ( self , displacement : list ) displaces the associated particle system with the prescribed amount around the center of mass.","title":"displace_particle_system"},{"location":"reference/src/ExternalForces/OpticalForceCalculator/#arguments","text":"displacement_range : list list of length 6 representing the displacement magnitudes to perform the stability test. First three values represent lateral displacement in meters. Next three values represent tilt angle around the centre of mass in degrees. View Source def displace_particle_system ( self , displacement : list ) : \"\"\" displaces the associated particle system with the prescribed amount around the center of mass. Arguments ---------- displacement_range : list list of length 6 representing the displacement magnitudes to perform the stability test. First three values represent lateral displacement in meters. Next three values represent tilt angle around the centre of mass in degrees. \"\"\" if len ( displacement ) != 6 : raise AttributeError ( \"Expected list of 6 arguments representing \" \"x,y,z,rx,ry,rz, got list of length {} instead\" . format ( len ( displacement ))) self . ParticleSystem . current_displacement = displacement qx , qy , qz , * _ = displacement COM = self . find_center_of_mass () locations , _ = PS . x_v_current_3D self . translate_mesh ( locations , - COM ) new_locations = self . rotate_mesh ( locations , displacement [ 3: ] ) new_locations = self . translate_mesh ( new_locations , displacement [ :3 ] ) new_locations = self . translate_mesh ( new_locations , COM ) for i , location in enumerate ( new_locations ) : # 'Unsafe' update needed to move fixed particles as well self . ParticleSystem . particles [ i ] . update_pos_unsafe ( location )","title":"Arguments"},{"location":"reference/src/ExternalForces/OpticalForceCalculator/#find_center_of_mass","text":"def find_center_of_mass ( self ) finds coordinates of center of mass of current mesh Returns: Type Description npt.ArrayLike [x,y,z] vector of center of mass View Source def find_center_of_mass ( self ) : \"\" \" finds coordinates of center of mass of current mesh Returns ------- COM : npt.ArrayLike [x,y,z] vector of center of mass \"\" \" locations, _ = PS.x_v_current_3D COM = np.mean(locations,axis=0) return COM","title":"find_center_of_mass"},{"location":"reference/src/ExternalForces/OpticalForceCalculator/#force_value","text":"def force_value ( self ) View Source def force_value ( self ) : PS = self . ParticleSystem LB = self . LaserBeam area_vectors = PS . find_surface () locations , _ = PS . x_v_current_3D forces = np . zeros ( locations . shape ) # adding index to locations for splitting and rejoining if not hasattr ( self , 'optical_type_mask' ) : self . create_optical_type_mask () # ! Note ! This bakes in implicitly that the orientation of the light # vector is in z + direction intensity_vectors = np . array ( [ [0,0,LB.intensity_profile(x,y) ] for x , y , z in locations ] ) for optical_type in self . optical_type_mask . keys () : if optical_type == ParticleOpticalPropertyType . SPECULAR : mask = self . optical_type_mask [ optical_type ] forces [ mask ] = self . calculate_specular_force ( area_vectors [ mask ] , intensity_vectors [ mask ] ) elif optical_type == ParticleOpticalPropertyType . AXICONGRATING : mask = self . optical_type_mask [ optical_type ] filtered_particles = compress ( PS . particles , mask ) axicon_angle = [ i.axicon_angle for i in filtered_particles ] forces [ mask ] = self . calculate_axicongrating_force ( area_vectors [ mask ] , intensity_vectors [ mask ] , axicon_angle ) return forces","title":"force_value"},{"location":"reference/src/ExternalForces/OpticalForceCalculator/#rotate_mesh","text":"def rotate_mesh ( self , mesh : Union [ numpy . __array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . __nested_sequence . _NestedSequence [ numpy . __array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . __nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], rotations : list ) Rotates mesh locations Parameters: Name Type Description Default mesh npt.ArrayLike shape n x 3 array holding x, y, z locations of each point None rotations list x, y, z axis rotation angles in degrees None Returns: Type Description npt.ArrayLike shape n x 3 array holding x, y, z locations of each point View Source def rotate_mesh ( self , mesh : npt . ArrayLike , rotations : list ) : \"\" \" Rotates mesh locations Parameters ---------- mesh : npt.ArrayLike shape n x 3 array holding x, y, z locations of each point rotations : list x, y, z axis rotation angles in degrees Returns ------- rotated_mesh : npt.ArrayLike shape n x 3 array holding x, y, z locations of each point \"\" \" gamma, beta, alpha = rotations rotation_matrix = Rotation.from_euler('zyx', [alpha, beta, gamma], degrees=True) rotated_mesh = np.matmul(rotation_matrix.as_matrix(), mesh.T).T return rotated_mesh","title":"rotate_mesh"},{"location":"reference/src/ExternalForces/OpticalForceCalculator/#translate_mesh","text":"def translate_mesh ( self , mesh , translation ) View Source def translate_mesh ( self , mesh , translation ) : qx , qy , qz = translation mesh [:, 0 ] += qx mesh [:, 1 ] += qy mesh [:, 2 ] += qz return mesh","title":"translate_mesh"},{"location":"reference/src/ExternalForces/OpticalForceCalculator/#un_displace_particle_system","text":"def un_displace_particle_system ( self ) Reverses current mesh displacement of the associated particle system. View Source def un_displace_particle_system ( self ): \"\"\" Reverses current mesh displacement of the associated particle system. \"\"\" if not hasattr ( self . ParticleSystem , ' current_displacement ' ): raise AttributeError ( \"Particle System is not currently displaced\" ) elif type ( self . ParticleSystem . current_displacement ) == type ( None ): raise AttributeError ( \"Particle System is not currently displaced\" ) current_displacement = self . ParticleSystem . current_displacement reverse_displacement = - np . array ( current_displacement ) self . displace_particle_system ( reverse_displacement ) self . ParticleSystem . current_displacement = None","title":"un_displace_particle_system"},{"location":"reference/src/ExternalForces/OpticalForceCalculator/#particleopticalpropertytype","text":"class ParticleOpticalPropertyType ( / , * args , ** kwargs ) Enumeration representing the various types of optical properties for the Particles","title":"ParticleOpticalPropertyType"},{"location":"reference/src/ExternalForces/OpticalForceCalculator/#attributes","text":"Name Type Description Default SPECULAR str Indicates that the particle reflects light specularly None ANISOTROPICSCATTERER str Indicates that the particle scatter light anisotropically None AXICONGRATING str Indicates that the particle scatter light like a cone NOTE: Directing angle should be set in the format of a rotation matrix for the relevant particles that represents [rx, ry] rotations of area vector on property particle.axicon_angle None View Source class ParticleOpticalPropertyType ( Enum ): \"\"\" Enumeration representing the various types of optical properties for the Particles Attributes ---------- SPECULAR : str Indicates that the particle reflects light specularly ANISOTROPICSCATTERER : str Indicates that the particle scatter light anisotropically AXICONGRATING : str Indicates that the particle scatter light like a cone NOTE: Directing angle should be set in the format of a rotation matrix for the relevant particles that represents [rx, ry] rotations of area vector on property particle.axicon_angle \"\"\" SPECULAR = \"specular\" AXICONGRATING = \"axicongrating\" ANISOTROPICSCATTERER = \"anisotropicscatterer\"","title":"Attributes"},{"location":"reference/src/ExternalForces/OpticalForceCalculator/#ancestors-in-mro_1","text":"enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/src/ExternalForces/OpticalForceCalculator/#class-variables","text":"ANISOTROPICSCATTERER AXICONGRATING SPECULAR name value","title":"Class variables"},{"location":"reference/src/Mesh/Mesher/","text":"Module src.Mesh.Mesher Created on Thu Dec 7 16:46:21 2023 View Source # -*- coding: utf-8 -*- \"\"\" Created on Thu Dec 7 16:46:21 2023 @author: Mark Kalsbeek \"\"\" import numpy as np from src.particleSystem.Particle import Particle from src.particleSystem.SpringDamper import SpringDamper from src.particleSystem.ParticleSystem import ParticleSystem class Mesher : def __init__ ( self ): self . shapes = [] def add_rectangle ( self , upper_left , lower_right , mesh_type ): self . shapes . append ( Rectangle ( upper_left , lower_right , mesh_type )) def mesh_shapes ( self ): return class Geometry : def __init__ ( self ): pass class Rectangle ( Geometry ): def __init__ ( self , upper_left , lower_right , angle = 0 ): self . upper_left = upper_left self . lower_right = lower_right self . angle = angle def mesh_square ( self , pattern_angle = 0 ): return def mesh_triangular ( self , pattern_angle = 0 ): return def mesh_hex ( self , pattern_angle = 0 ): return def mesh_square_cross ( self , pattern_angle = 0 ): return class Ellipse ( Geometry ): def __init__ ( self , center , radius , eccentricity = 0 , angle = 0 ): self . center = center self . radius = radius self . eccentricity = eccentricity self . angle = angle def mesh_square ( self ): return def mesh_triangular ( self ): return def mesh_hex ( self ): return def mesh_square_cross ( self ): return Classes Ellipse class Ellipse ( center , radius , eccentricity = 0 , angle = 0 ) View Source class Ellipse ( Geometry ): def __init__ ( self , center , radius , eccentricity = 0 , angle = 0 ): self . center = center self . radius = radius self . eccentricity = eccentricity self . angle = angle def mesh_square ( self ): return def mesh_triangular ( self ): return def mesh_hex ( self ): return def mesh_square_cross ( self ): return Ancestors (in MRO) src.Mesh.Mesher.Geometry Methods mesh_hex def mesh_hex ( self ) View Source def mesh_hex ( self ) : return mesh_square def mesh_square ( self ) View Source def mesh_square ( self ) : return mesh_square_cross def mesh_square_cross ( self ) View Source def mesh_square_cross ( self ) : return mesh_triangular def mesh_triangular ( self ) View Source def mesh_triangular ( self ) : return Geometry class Geometry ( ) View Source class Geometry: def __init__ ( self ): pass Descendants src.Mesh.Mesher.Rectangle src.Mesh.Mesher.Ellipse Mesher class Mesher ( ) View Source class Mesher : def __init__ ( self ): self . shapes = [] def add_rectangle ( self , upper_left , lower_right , mesh_type ): self . shapes . append ( Rectangle ( upper_left , lower_right , mesh_type )) def mesh_shapes ( self ): return Methods add_rectangle def add_rectangle ( self , upper_left , lower_right , mesh_type ) View Source def add_rectangle ( self , upper_left , lower_right , mesh_type ): self . shapes . append ( Rectangle ( upper_left , lower_right , mesh_type )) mesh_shapes def mesh_shapes ( self ) View Source def mesh_shapes ( self ) : return Rectangle class Rectangle ( upper_left , lower_right , angle = 0 ) View Source class Rectangle ( Geometry ): def __init__ ( self , upper_left , lower_right , angle = 0 ): self . upper_left = upper_left self . lower_right = lower_right self . angle = angle def mesh_square ( self , pattern_angle = 0 ): return def mesh_triangular ( self , pattern_angle = 0 ): return def mesh_hex ( self , pattern_angle = 0 ): return def mesh_square_cross ( self , pattern_angle = 0 ): return Ancestors (in MRO) src.Mesh.Mesher.Geometry Methods mesh_hex def mesh_hex ( self , pattern_angle = 0 ) View Source def mesh_hex ( self , pattern_angle = 0 ) : return mesh_square def mesh_square ( self , pattern_angle = 0 ) View Source def mesh_square ( self , pattern_angle = 0 ) : return mesh_square_cross def mesh_square_cross ( self , pattern_angle = 0 ) View Source def mesh_square_cross ( self , pattern_angle = 0 ) : return mesh_triangular def mesh_triangular ( self , pattern_angle = 0 ) View Source def mesh_triangular ( self , pattern_angle = 0 ) : return","title":"Mesher"},{"location":"reference/src/Mesh/Mesher/#module-srcmeshmesher","text":"Created on Thu Dec 7 16:46:21 2023 View Source # -*- coding: utf-8 -*- \"\"\" Created on Thu Dec 7 16:46:21 2023 @author: Mark Kalsbeek \"\"\" import numpy as np from src.particleSystem.Particle import Particle from src.particleSystem.SpringDamper import SpringDamper from src.particleSystem.ParticleSystem import ParticleSystem class Mesher : def __init__ ( self ): self . shapes = [] def add_rectangle ( self , upper_left , lower_right , mesh_type ): self . shapes . append ( Rectangle ( upper_left , lower_right , mesh_type )) def mesh_shapes ( self ): return class Geometry : def __init__ ( self ): pass class Rectangle ( Geometry ): def __init__ ( self , upper_left , lower_right , angle = 0 ): self . upper_left = upper_left self . lower_right = lower_right self . angle = angle def mesh_square ( self , pattern_angle = 0 ): return def mesh_triangular ( self , pattern_angle = 0 ): return def mesh_hex ( self , pattern_angle = 0 ): return def mesh_square_cross ( self , pattern_angle = 0 ): return class Ellipse ( Geometry ): def __init__ ( self , center , radius , eccentricity = 0 , angle = 0 ): self . center = center self . radius = radius self . eccentricity = eccentricity self . angle = angle def mesh_square ( self ): return def mesh_triangular ( self ): return def mesh_hex ( self ): return def mesh_square_cross ( self ): return","title":"Module src.Mesh.Mesher"},{"location":"reference/src/Mesh/Mesher/#classes","text":"","title":"Classes"},{"location":"reference/src/Mesh/Mesher/#ellipse","text":"class Ellipse ( center , radius , eccentricity = 0 , angle = 0 ) View Source class Ellipse ( Geometry ): def __init__ ( self , center , radius , eccentricity = 0 , angle = 0 ): self . center = center self . radius = radius self . eccentricity = eccentricity self . angle = angle def mesh_square ( self ): return def mesh_triangular ( self ): return def mesh_hex ( self ): return def mesh_square_cross ( self ): return","title":"Ellipse"},{"location":"reference/src/Mesh/Mesher/#ancestors-in-mro","text":"src.Mesh.Mesher.Geometry","title":"Ancestors (in MRO)"},{"location":"reference/src/Mesh/Mesher/#methods","text":"","title":"Methods"},{"location":"reference/src/Mesh/Mesher/#mesh_hex","text":"def mesh_hex ( self ) View Source def mesh_hex ( self ) : return","title":"mesh_hex"},{"location":"reference/src/Mesh/Mesher/#mesh_square","text":"def mesh_square ( self ) View Source def mesh_square ( self ) : return","title":"mesh_square"},{"location":"reference/src/Mesh/Mesher/#mesh_square_cross","text":"def mesh_square_cross ( self ) View Source def mesh_square_cross ( self ) : return","title":"mesh_square_cross"},{"location":"reference/src/Mesh/Mesher/#mesh_triangular","text":"def mesh_triangular ( self ) View Source def mesh_triangular ( self ) : return","title":"mesh_triangular"},{"location":"reference/src/Mesh/Mesher/#geometry","text":"class Geometry ( ) View Source class Geometry: def __init__ ( self ): pass","title":"Geometry"},{"location":"reference/src/Mesh/Mesher/#descendants","text":"src.Mesh.Mesher.Rectangle src.Mesh.Mesher.Ellipse","title":"Descendants"},{"location":"reference/src/Mesh/Mesher/#mesher","text":"class Mesher ( ) View Source class Mesher : def __init__ ( self ): self . shapes = [] def add_rectangle ( self , upper_left , lower_right , mesh_type ): self . shapes . append ( Rectangle ( upper_left , lower_right , mesh_type )) def mesh_shapes ( self ): return","title":"Mesher"},{"location":"reference/src/Mesh/Mesher/#methods_1","text":"","title":"Methods"},{"location":"reference/src/Mesh/Mesher/#add_rectangle","text":"def add_rectangle ( self , upper_left , lower_right , mesh_type ) View Source def add_rectangle ( self , upper_left , lower_right , mesh_type ): self . shapes . append ( Rectangle ( upper_left , lower_right , mesh_type ))","title":"add_rectangle"},{"location":"reference/src/Mesh/Mesher/#mesh_shapes","text":"def mesh_shapes ( self ) View Source def mesh_shapes ( self ) : return","title":"mesh_shapes"},{"location":"reference/src/Mesh/Mesher/#rectangle","text":"class Rectangle ( upper_left , lower_right , angle = 0 ) View Source class Rectangle ( Geometry ): def __init__ ( self , upper_left , lower_right , angle = 0 ): self . upper_left = upper_left self . lower_right = lower_right self . angle = angle def mesh_square ( self , pattern_angle = 0 ): return def mesh_triangular ( self , pattern_angle = 0 ): return def mesh_hex ( self , pattern_angle = 0 ): return def mesh_square_cross ( self , pattern_angle = 0 ): return","title":"Rectangle"},{"location":"reference/src/Mesh/Mesher/#ancestors-in-mro_1","text":"src.Mesh.Mesher.Geometry","title":"Ancestors (in MRO)"},{"location":"reference/src/Mesh/Mesher/#methods_2","text":"","title":"Methods"},{"location":"reference/src/Mesh/Mesher/#mesh_hex_1","text":"def mesh_hex ( self , pattern_angle = 0 ) View Source def mesh_hex ( self , pattern_angle = 0 ) : return","title":"mesh_hex"},{"location":"reference/src/Mesh/Mesher/#mesh_square_1","text":"def mesh_square ( self , pattern_angle = 0 ) View Source def mesh_square ( self , pattern_angle = 0 ) : return","title":"mesh_square"},{"location":"reference/src/Mesh/Mesher/#mesh_square_cross_1","text":"def mesh_square_cross ( self , pattern_angle = 0 ) View Source def mesh_square_cross ( self , pattern_angle = 0 ) : return","title":"mesh_square_cross"},{"location":"reference/src/Mesh/Mesher/#mesh_triangular_1","text":"def mesh_triangular ( self , pattern_angle = 0 ) View Source def mesh_triangular ( self , pattern_angle = 0 ) : return","title":"mesh_triangular"},{"location":"reference/src/particleSystem/Particle/","text":"Module src.particleSystem.Particle Child Class 'Particle', for particle objects to be instantiated in ParticleSystem View Source \"\"\" Child Class 'Particle', for particle objects to be instantiated in ParticleSystem \"\"\" from src.particleSystem.SystemObject import SystemObject import numpy as np import numpy.typing as npt class Particle ( SystemObject ): def __init__ ( self , x : npt . ArrayLike , v : npt . ArrayLike , m : float , fixed : bool , constraint : npt . NDArray = None , constraint_type : str = 'free' ): \"\"\" Object that holds particle data Parameters ---------- x : npt.ArrayLike Position (x,y,z) in meter v : npt.ArrayLike Velocity (x,y,z) in meters per second m : float Mass in kilograms fixed : bool Wether or not the particle is fixed constraint : npt.NDArray, optional Desrcribes specific constraint if particle is fixed. The default is None. This indicates that it's fixed in all three dimentions. constraint_type : str, optional Describes constraint type. Can be free, point, line or plane Can be left default for fixed points, as they're indicated by passing constraint = [0,0,0] Raises ------ AttributeError Raises error if constraint is set incorrectly. Returns ------- None. \"\"\" self . __x = np . array ( x , dtype = 'float64' ) self . __v = np . array ( v , dtype = 'float64' ) self . __m = m self . __fixed = fixed self . __constraint = None self . __constraint_type = constraint_type . lower () if self . __fixed : self . validate_constraint ( constraint ) self . constraint_projection () super () . __init__ () def __str__ ( self ): return ( f \"Particle Object, position [m]: [ { self . __x [ 0 ] } , { self . __x [ 1 ] } , { self . __x [ 2 ] } ], \" f \"velocity [m/s]: [ { self . __v [ 0 ] } , { self . __v [ 1 ] } , { self . __v [ 2 ] } ], mass [kg]: { self . __m } \" f \", fixed: { self . __fixed } , { self . __constraint =} , { self . __constraint_type =} \" ) def validate_constraint ( self , constraint ): \"Checks if constraint is entered correctly, raises exception if otherwise\" if self . __fixed : if constraint == None : constraint = [ 0 , 0 , 0 ] self . __constraint_type = 'point' if self . __constraint_type not in [ 'point' , 'line' , 'plane' ]: raise AttributeError ( f \"Incorrect constraint type set, expected\" f \" line or plane, got \" f \" { self . __constraint_type } \" ) try : self . __constraint = np . array ( constraint , dtype = float ) . reshape ( 1 , 3 ) except ( ValueError , TypeError ) as e : raise AttributeError ( f \"Particle set as 'fixed' but constraint \" f \"not set correctly. Expecting (1,3) \" f \"npt.Arraylike, instead got \" f \" { constraint =} . Error: { e } \" ) else : self . __constraint = None def constraint_projection ( self ): if np . sum ( self . __constraint == 0 ) == 3 : self . constraint_projection_matrix = np . zeros (( 3 , 3 )) else : normalised_constraint = self . __constraint / np . linalg . norm ( self . __constraint ) if self . __constraint_type == 'plane' : projection_matrix = np . eye ( 3 ) - np . outer ( normalised_constraint , normalised_constraint ) self . constraint_projection_matrix = projection_matrix elif self . __constraint_type == 'line' : projection_matrix = np . outer ( normalised_constraint , normalised_constraint ) self . constraint_projection_matrix = projection_matrix def update_pos ( self , new_pos : npt . ArrayLike ): if not self . __fixed : self . __x = np . array ( new_pos ) else : self . __x += self . constraint_projection_matrix . dot ( np . array ( new_pos ) - self . __x ) def update_pos_unsafe ( self , new_pos : npt . ArrayLike ): \"\"\"position update method that will override locations of fixed nodes\"\"\" self . __x = np . array ( new_pos ) def update_vel ( self , new_vel : npt . ArrayLike ): if not self . __fixed : self . __v = np . array ( new_vel ) else : self . __v += self . constraint_projection_matrix . dot ( np . array ( new_vel ) - self . __v ) @property def x ( self ): return self . __x @property def v ( self ): return self . __v @property def m ( self ): return self . __m @property def fixed ( self ): return self . __fixed def set_fixed ( self , fixed , constraint = None , constraint_type = 'free' ): self . __fixed = fixed self . validate_constraint ( constraint ) self . __constraint_type = constraint_type if self . __fixed : self . constraint_projection () @property def constraint_type ( self ): return self . __constraint_type if __name__ == \"__main__\" : position = [ 0 , 0 , 0 ] velocity = [ 0 , 0 , 0 ] mass = 1 fixed1 = False fixed2 = True constraint2 = [ - 1 , 0 , 1 ] constraint_type2 = 'line' p1 = Particle ( position , velocity , mass , fixed1 ) p2 = Particle ( position , velocity , mass , fixed2 , constraint2 , constraint_type2 ) print ( 'Starting positions' ) print ( p1 ) print ( p2 , ' \\n ' ) updated_pos = [ 0 , 1 , 1 ] updated_vel = [ 0 , 0 , 1 ] p1 . update_pos ( updated_pos ) p1 . update_vel ( updated_vel ) p2 . update_pos ( updated_pos ) p2 . update_vel ( updated_vel ) print ( 'Updated positions' ) print ( p1 ) print ( p2 ) Classes Particle class Particle ( x : Union [ numpy . __array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . __nested_sequence . _NestedSequence [ numpy . __array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . __nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], v : Union [ numpy . __array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . __nested_sequence . _NestedSequence [ numpy . __array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . __nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], m : float , fixed : bool , constraint : numpy . ndarray [ typing . Any , numpy . dtype [ + _ScalarType_co ]] = None , constraint_type : str = 'free' ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Particle ( SystemObject ) : def __init__ ( self , x : npt . ArrayLike , v : npt . ArrayLike , m : float , fixed : bool , constraint : npt . NDArray = None , constraint_type : str = 'free' ) : \"\"\" Object that holds particle data Parameters ---------- x : npt.ArrayLike Position (x,y,z) in meter v : npt.ArrayLike Velocity (x,y,z) in meters per second m : float Mass in kilograms fixed : bool Wether or not the particle is fixed constraint : npt.NDArray, optional Desrcribes specific constraint if particle is fixed. The default is None. This indicates that it's fixed in all three dimentions. constraint_type : str, optional Describes constraint type. Can be free, point, line or plane Can be left default for fixed points, as they're indicated by passing constraint = [0,0,0] Raises ------ AttributeError Raises error if constraint is set incorrectly. Returns ------- None. \"\"\" self . __x = np . array ( x , dtype = 'float64' ) self . __v = np . array ( v , dtype = 'float64' ) self . __m = m self . __fixed = fixed self . __constraint = None self . __constraint_type = constraint_type . lower () if self . __fixed : self . validate_constraint ( constraint ) self . constraint_projection () super (). __init__ () def __str__ ( self ) : return ( f \"Particle Object, position [m]: [{self.__x[0]}, {self.__x[1]}, {self.__x[2]}], \" f \"velocity [m/s]: [{self.__v[0]}, {self.__v[1]}, {self.__v[2]}], mass [kg]: {self.__m}\" f \", fixed: {self.__fixed}, {self.__constraint=}, {self.__constraint_type=}\" ) def validate_constraint ( self , constraint ) : \"Checks if constraint is entered correctly, raises exception if otherwise\" if self . __fixed : if constraint == None : constraint = [ 0,0,0 ] self . __constraint_type = 'point' if self . __constraint_type not in [ 'point', 'line', 'plane' ] : raise AttributeError ( f \"Incorrect constraint type set, expected\" f \" line or plane, got \" f \"{self.__constraint_type}\" ) try : self . __constraint = np . array ( constraint , dtype = float ). reshape ( 1 , 3 ) except ( ValueError , TypeError ) as e : raise AttributeError ( f \"Particle set as 'fixed' but constraint \" f \"not set correctly. Expecting (1,3) \" f \"npt.Arraylike, instead got \" f \"{constraint=}. Error: {e}\" ) else : self . __constraint = None def constraint_projection ( self ) : if np . sum ( self . __constraint == 0 ) == 3 : self . constraint_projection_matrix = np . zeros (( 3 , 3 )) else : normalised_constraint = self . __constraint / np . linalg . norm ( self . __constraint ) if self . __constraint_type == 'plane' : projection_matrix = np . eye ( 3 ) - np . outer ( normalised_constraint , normalised_constraint ) self . constraint_projection_matrix = projection_matrix elif self . __constraint_type == 'line' : projection_matrix = np . outer ( normalised_constraint , normalised_constraint ) self . constraint_projection_matrix = projection_matrix def update_pos ( self , new_pos : npt . ArrayLike ) : if not self . __fixed : self . __x = np . array ( new_pos ) else : self . __x += self . constraint_projection_matrix . dot ( np . array ( new_pos ) - self . __x ) def update_pos_unsafe ( self , new_pos : npt . ArrayLike ) : \"\"\"position update method that will override locations of fixed nodes\"\"\" self . __x = np . array ( new_pos ) def update_vel ( self , new_vel : npt . ArrayLike ) : if not self . __fixed : self . __v = np . array ( new_vel ) else : self . __v += self . constraint_projection_matrix . dot ( np . array ( new_vel ) - self . __v ) @property def x ( self ) : return self . __x @property def v ( self ) : return self . __v @property def m ( self ) : return self . __m @property def fixed ( self ) : return self . __fixed def set_fixed ( self , fixed , constraint = None , constraint_type = 'free' ) : self . __fixed = fixed self . validate_constraint ( constraint ) self . __constraint_type = constraint_type if self . __fixed : self . constraint_projection () @property def constraint_type ( self ) : return self . __constraint_type Ancestors (in MRO) src.particleSystem.SystemObject.SystemObject abc.ABC Instance variables constraint_type fixed m v x Methods constraint_projection def constraint_projection ( self ) View Source def constraint_projection ( self ): if np . sum ( self . __constraint == 0 ) == 3 : self . constraint_projection_matrix = np . zeros (( 3 , 3 )) else : normalised_constraint = self . __constraint / np . linalg . norm ( self . __constraint ) if self . __constraint_type == ' plane ' : projection_matrix = np . eye ( 3 ) - np . outer ( normalised_constraint , normalised_constraint ) self . constraint_projection_matrix = projection_matrix elif self . __constraint_type == ' line ' : projection_matrix = np . outer ( normalised_constraint , normalised_constraint ) self . constraint_projection_matrix = projection_matrix set_fixed def set_fixed ( self , fixed , constraint = None , constraint_type = 'free' ) View Source def set_fixed ( self , fixed , constraint = None , constraint_type = ' free ' ): self . __fixed = fixed self . validate_constraint ( constraint ) self . __constraint_type = constraint_type if self . __fixed : self . constraint_projection () update_pos def update_pos ( self , new_pos : Union [ numpy . __array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . __nested_sequence . _NestedSequence [ numpy . __array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . __nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) View Source def update_pos ( self , new_pos : npt . ArrayLike ): if not self . __fixed : self . __x = np . array ( new_pos ) else : self . __x += self . constraint_projection_matrix . dot ( np . array ( new_pos ) - self . __x ) update_pos_unsafe def update_pos_unsafe ( self , new_pos : Union [ numpy . __array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . __nested_sequence . _NestedSequence [ numpy . __array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . __nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) position update method that will override locations of fixed nodes View Source def update_pos_unsafe(self, new_pos : npt.ArrayLike): \"\"\"position update method that will override locations of fixed nodes\"\"\" self.__x = np.array(new_pos) update_vel def update_vel ( self , new_vel : Union [ numpy . __array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . __nested_sequence . _NestedSequence [ numpy . __array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . __nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) View Source def update_vel ( self , new_vel : npt . ArrayLike ): if not self . __fixed : self . __v = np . array ( new_vel ) else : self . __v += self . constraint_projection_matrix . dot ( np . array ( new_vel ) - self . __v ) validate_constraint def validate_constraint ( self , constraint ) Checks if constraint is entered correctly, raises exception if otherwise View Source def validate_constraint ( self , constraint ): \"Checks if constraint is entered correctly, raises exception if otherwise\" if self . __fixed : if constraint == None : constraint = [ 0 , 0 , 0 ] self . __constraint_type = ' point ' if self . __constraint_type not in [ ' point ' , ' line ' , ' plane ' ]: raise AttributeError ( f \"Incorrect constraint type set, expected\" f \" line or plane, got \" f \"{self.__constraint_type}\" ) try : self . __constraint = np . array ( constraint , dtype = float ). reshape ( 1 , 3 ) except ( ValueError , TypeError ) as e : raise AttributeError ( f \"Particle set as 'fixed' but constraint \" f \"not set correctly. Expecting (1,3) \" f \"npt.Arraylike, instead got \" f \"{constraint=}. Error: {e}\" ) else : self . __constraint = None","title":"Particle"},{"location":"reference/src/particleSystem/Particle/#module-srcparticlesystemparticle","text":"Child Class 'Particle', for particle objects to be instantiated in ParticleSystem View Source \"\"\" Child Class 'Particle', for particle objects to be instantiated in ParticleSystem \"\"\" from src.particleSystem.SystemObject import SystemObject import numpy as np import numpy.typing as npt class Particle ( SystemObject ): def __init__ ( self , x : npt . ArrayLike , v : npt . ArrayLike , m : float , fixed : bool , constraint : npt . NDArray = None , constraint_type : str = 'free' ): \"\"\" Object that holds particle data Parameters ---------- x : npt.ArrayLike Position (x,y,z) in meter v : npt.ArrayLike Velocity (x,y,z) in meters per second m : float Mass in kilograms fixed : bool Wether or not the particle is fixed constraint : npt.NDArray, optional Desrcribes specific constraint if particle is fixed. The default is None. This indicates that it's fixed in all three dimentions. constraint_type : str, optional Describes constraint type. Can be free, point, line or plane Can be left default for fixed points, as they're indicated by passing constraint = [0,0,0] Raises ------ AttributeError Raises error if constraint is set incorrectly. Returns ------- None. \"\"\" self . __x = np . array ( x , dtype = 'float64' ) self . __v = np . array ( v , dtype = 'float64' ) self . __m = m self . __fixed = fixed self . __constraint = None self . __constraint_type = constraint_type . lower () if self . __fixed : self . validate_constraint ( constraint ) self . constraint_projection () super () . __init__ () def __str__ ( self ): return ( f \"Particle Object, position [m]: [ { self . __x [ 0 ] } , { self . __x [ 1 ] } , { self . __x [ 2 ] } ], \" f \"velocity [m/s]: [ { self . __v [ 0 ] } , { self . __v [ 1 ] } , { self . __v [ 2 ] } ], mass [kg]: { self . __m } \" f \", fixed: { self . __fixed } , { self . __constraint =} , { self . __constraint_type =} \" ) def validate_constraint ( self , constraint ): \"Checks if constraint is entered correctly, raises exception if otherwise\" if self . __fixed : if constraint == None : constraint = [ 0 , 0 , 0 ] self . __constraint_type = 'point' if self . __constraint_type not in [ 'point' , 'line' , 'plane' ]: raise AttributeError ( f \"Incorrect constraint type set, expected\" f \" line or plane, got \" f \" { self . __constraint_type } \" ) try : self . __constraint = np . array ( constraint , dtype = float ) . reshape ( 1 , 3 ) except ( ValueError , TypeError ) as e : raise AttributeError ( f \"Particle set as 'fixed' but constraint \" f \"not set correctly. Expecting (1,3) \" f \"npt.Arraylike, instead got \" f \" { constraint =} . Error: { e } \" ) else : self . __constraint = None def constraint_projection ( self ): if np . sum ( self . __constraint == 0 ) == 3 : self . constraint_projection_matrix = np . zeros (( 3 , 3 )) else : normalised_constraint = self . __constraint / np . linalg . norm ( self . __constraint ) if self . __constraint_type == 'plane' : projection_matrix = np . eye ( 3 ) - np . outer ( normalised_constraint , normalised_constraint ) self . constraint_projection_matrix = projection_matrix elif self . __constraint_type == 'line' : projection_matrix = np . outer ( normalised_constraint , normalised_constraint ) self . constraint_projection_matrix = projection_matrix def update_pos ( self , new_pos : npt . ArrayLike ): if not self . __fixed : self . __x = np . array ( new_pos ) else : self . __x += self . constraint_projection_matrix . dot ( np . array ( new_pos ) - self . __x ) def update_pos_unsafe ( self , new_pos : npt . ArrayLike ): \"\"\"position update method that will override locations of fixed nodes\"\"\" self . __x = np . array ( new_pos ) def update_vel ( self , new_vel : npt . ArrayLike ): if not self . __fixed : self . __v = np . array ( new_vel ) else : self . __v += self . constraint_projection_matrix . dot ( np . array ( new_vel ) - self . __v ) @property def x ( self ): return self . __x @property def v ( self ): return self . __v @property def m ( self ): return self . __m @property def fixed ( self ): return self . __fixed def set_fixed ( self , fixed , constraint = None , constraint_type = 'free' ): self . __fixed = fixed self . validate_constraint ( constraint ) self . __constraint_type = constraint_type if self . __fixed : self . constraint_projection () @property def constraint_type ( self ): return self . __constraint_type if __name__ == \"__main__\" : position = [ 0 , 0 , 0 ] velocity = [ 0 , 0 , 0 ] mass = 1 fixed1 = False fixed2 = True constraint2 = [ - 1 , 0 , 1 ] constraint_type2 = 'line' p1 = Particle ( position , velocity , mass , fixed1 ) p2 = Particle ( position , velocity , mass , fixed2 , constraint2 , constraint_type2 ) print ( 'Starting positions' ) print ( p1 ) print ( p2 , ' \\n ' ) updated_pos = [ 0 , 1 , 1 ] updated_vel = [ 0 , 0 , 1 ] p1 . update_pos ( updated_pos ) p1 . update_vel ( updated_vel ) p2 . update_pos ( updated_pos ) p2 . update_vel ( updated_vel ) print ( 'Updated positions' ) print ( p1 ) print ( p2 )","title":"Module src.particleSystem.Particle"},{"location":"reference/src/particleSystem/Particle/#classes","text":"","title":"Classes"},{"location":"reference/src/particleSystem/Particle/#particle","text":"class Particle ( x : Union [ numpy . __array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . __nested_sequence . _NestedSequence [ numpy . __array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . __nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], v : Union [ numpy . __array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . __nested_sequence . _NestedSequence [ numpy . __array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . __nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], m : float , fixed : bool , constraint : numpy . ndarray [ typing . Any , numpy . dtype [ + _ScalarType_co ]] = None , constraint_type : str = 'free' ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Particle ( SystemObject ) : def __init__ ( self , x : npt . ArrayLike , v : npt . ArrayLike , m : float , fixed : bool , constraint : npt . NDArray = None , constraint_type : str = 'free' ) : \"\"\" Object that holds particle data Parameters ---------- x : npt.ArrayLike Position (x,y,z) in meter v : npt.ArrayLike Velocity (x,y,z) in meters per second m : float Mass in kilograms fixed : bool Wether or not the particle is fixed constraint : npt.NDArray, optional Desrcribes specific constraint if particle is fixed. The default is None. This indicates that it's fixed in all three dimentions. constraint_type : str, optional Describes constraint type. Can be free, point, line or plane Can be left default for fixed points, as they're indicated by passing constraint = [0,0,0] Raises ------ AttributeError Raises error if constraint is set incorrectly. Returns ------- None. \"\"\" self . __x = np . array ( x , dtype = 'float64' ) self . __v = np . array ( v , dtype = 'float64' ) self . __m = m self . __fixed = fixed self . __constraint = None self . __constraint_type = constraint_type . lower () if self . __fixed : self . validate_constraint ( constraint ) self . constraint_projection () super (). __init__ () def __str__ ( self ) : return ( f \"Particle Object, position [m]: [{self.__x[0]}, {self.__x[1]}, {self.__x[2]}], \" f \"velocity [m/s]: [{self.__v[0]}, {self.__v[1]}, {self.__v[2]}], mass [kg]: {self.__m}\" f \", fixed: {self.__fixed}, {self.__constraint=}, {self.__constraint_type=}\" ) def validate_constraint ( self , constraint ) : \"Checks if constraint is entered correctly, raises exception if otherwise\" if self . __fixed : if constraint == None : constraint = [ 0,0,0 ] self . __constraint_type = 'point' if self . __constraint_type not in [ 'point', 'line', 'plane' ] : raise AttributeError ( f \"Incorrect constraint type set, expected\" f \" line or plane, got \" f \"{self.__constraint_type}\" ) try : self . __constraint = np . array ( constraint , dtype = float ). reshape ( 1 , 3 ) except ( ValueError , TypeError ) as e : raise AttributeError ( f \"Particle set as 'fixed' but constraint \" f \"not set correctly. Expecting (1,3) \" f \"npt.Arraylike, instead got \" f \"{constraint=}. Error: {e}\" ) else : self . __constraint = None def constraint_projection ( self ) : if np . sum ( self . __constraint == 0 ) == 3 : self . constraint_projection_matrix = np . zeros (( 3 , 3 )) else : normalised_constraint = self . __constraint / np . linalg . norm ( self . __constraint ) if self . __constraint_type == 'plane' : projection_matrix = np . eye ( 3 ) - np . outer ( normalised_constraint , normalised_constraint ) self . constraint_projection_matrix = projection_matrix elif self . __constraint_type == 'line' : projection_matrix = np . outer ( normalised_constraint , normalised_constraint ) self . constraint_projection_matrix = projection_matrix def update_pos ( self , new_pos : npt . ArrayLike ) : if not self . __fixed : self . __x = np . array ( new_pos ) else : self . __x += self . constraint_projection_matrix . dot ( np . array ( new_pos ) - self . __x ) def update_pos_unsafe ( self , new_pos : npt . ArrayLike ) : \"\"\"position update method that will override locations of fixed nodes\"\"\" self . __x = np . array ( new_pos ) def update_vel ( self , new_vel : npt . ArrayLike ) : if not self . __fixed : self . __v = np . array ( new_vel ) else : self . __v += self . constraint_projection_matrix . dot ( np . array ( new_vel ) - self . __v ) @property def x ( self ) : return self . __x @property def v ( self ) : return self . __v @property def m ( self ) : return self . __m @property def fixed ( self ) : return self . __fixed def set_fixed ( self , fixed , constraint = None , constraint_type = 'free' ) : self . __fixed = fixed self . validate_constraint ( constraint ) self . __constraint_type = constraint_type if self . __fixed : self . constraint_projection () @property def constraint_type ( self ) : return self . __constraint_type","title":"Particle"},{"location":"reference/src/particleSystem/Particle/#ancestors-in-mro","text":"src.particleSystem.SystemObject.SystemObject abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/src/particleSystem/Particle/#instance-variables","text":"constraint_type fixed m v x","title":"Instance variables"},{"location":"reference/src/particleSystem/Particle/#methods","text":"","title":"Methods"},{"location":"reference/src/particleSystem/Particle/#constraint_projection","text":"def constraint_projection ( self ) View Source def constraint_projection ( self ): if np . sum ( self . __constraint == 0 ) == 3 : self . constraint_projection_matrix = np . zeros (( 3 , 3 )) else : normalised_constraint = self . __constraint / np . linalg . norm ( self . __constraint ) if self . __constraint_type == ' plane ' : projection_matrix = np . eye ( 3 ) - np . outer ( normalised_constraint , normalised_constraint ) self . constraint_projection_matrix = projection_matrix elif self . __constraint_type == ' line ' : projection_matrix = np . outer ( normalised_constraint , normalised_constraint ) self . constraint_projection_matrix = projection_matrix","title":"constraint_projection"},{"location":"reference/src/particleSystem/Particle/#set_fixed","text":"def set_fixed ( self , fixed , constraint = None , constraint_type = 'free' ) View Source def set_fixed ( self , fixed , constraint = None , constraint_type = ' free ' ): self . __fixed = fixed self . validate_constraint ( constraint ) self . __constraint_type = constraint_type if self . __fixed : self . constraint_projection ()","title":"set_fixed"},{"location":"reference/src/particleSystem/Particle/#update_pos","text":"def update_pos ( self , new_pos : Union [ numpy . __array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . __nested_sequence . _NestedSequence [ numpy . __array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . __nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) View Source def update_pos ( self , new_pos : npt . ArrayLike ): if not self . __fixed : self . __x = np . array ( new_pos ) else : self . __x += self . constraint_projection_matrix . dot ( np . array ( new_pos ) - self . __x )","title":"update_pos"},{"location":"reference/src/particleSystem/Particle/#update_pos_unsafe","text":"def update_pos_unsafe ( self , new_pos : Union [ numpy . __array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . __nested_sequence . _NestedSequence [ numpy . __array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . __nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) position update method that will override locations of fixed nodes View Source def update_pos_unsafe(self, new_pos : npt.ArrayLike): \"\"\"position update method that will override locations of fixed nodes\"\"\" self.__x = np.array(new_pos)","title":"update_pos_unsafe"},{"location":"reference/src/particleSystem/Particle/#update_vel","text":"def update_vel ( self , new_vel : Union [ numpy . __array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . __nested_sequence . _NestedSequence [ numpy . __array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . __nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) View Source def update_vel ( self , new_vel : npt . ArrayLike ): if not self . __fixed : self . __v = np . array ( new_vel ) else : self . __v += self . constraint_projection_matrix . dot ( np . array ( new_vel ) - self . __v )","title":"update_vel"},{"location":"reference/src/particleSystem/Particle/#validate_constraint","text":"def validate_constraint ( self , constraint ) Checks if constraint is entered correctly, raises exception if otherwise View Source def validate_constraint ( self , constraint ): \"Checks if constraint is entered correctly, raises exception if otherwise\" if self . __fixed : if constraint == None : constraint = [ 0 , 0 , 0 ] self . __constraint_type = ' point ' if self . __constraint_type not in [ ' point ' , ' line ' , ' plane ' ]: raise AttributeError ( f \"Incorrect constraint type set, expected\" f \" line or plane, got \" f \"{self.__constraint_type}\" ) try : self . __constraint = np . array ( constraint , dtype = float ). reshape ( 1 , 3 ) except ( ValueError , TypeError ) as e : raise AttributeError ( f \"Particle set as 'fixed' but constraint \" f \"not set correctly. Expecting (1,3) \" f \"npt.Arraylike, instead got \" f \"{constraint=}. Error: {e}\" ) else : self . __constraint = None","title":"validate_constraint"},{"location":"reference/src/particleSystem/ParticleSystem/","text":"Module src.particleSystem.ParticleSystem ParticleSystem framework ... View Source \"\"\" ParticleSystem framework ... \"\"\" import logging import numpy as np import numpy.typing as npt from scipy.sparse.linalg import bicgstab import scipy.sparse from scipy.spatial import Delaunay import matplotlib.pyplot as plt from mpl_toolkits.mplot3d.art3d import Line3DCollection from src.particleSystem.Particle import Particle from src.particleSystem.SpringDamper import SpringDamper class ParticleSystem : def __init__ ( self , connectivity_matrix : list , initial_conditions : npt . ArrayLike , sim_param : dict ): \"\"\" Constructor for ParticleSystem object, model made up of n particles Parameters --------- connectivity_matrix : list 2-by-m matrix, where each column contains a nodal index pair that is connectedby a spring element. initial_conditions : npt.ArrayLike Array of n arrays to instantiate particles. Each subarray must contain the params required for the particle constructor: [initial_pos, initial_vel, mass, fixed: bool, constraint] param sim_param : dict Dictionary of other parameters required for simulation (dt, rtol, ...) \"\"\" self . __connectivity_matrix = connectivity_matrix self . __n = len ( initial_conditions ) self . __dt = sim_param [ \"dt\" ] self . __rtol = sim_param [ \"rel_tol\" ] self . __atol = sim_param [ \"abs_tol\" ] self . __maxiter = sim_param [ \"max_iter\" ] # allocate memory self . __particles = [] self . __springdampers = [] self . __f = np . zeros (( self . __n * 3 , )) self . __jx = np . zeros (( self . __n * 3 , self . __n * 3 )) self . __jv = np . zeros (( self . __n * 3 , self . __n * 3 )) self . __instantiate_particles ( initial_conditions ) self . __m_matrix = self . __construct_m_matrix () self . __instantiate_springdampers () # Variables required for kinetic damping self . __w_kin = self . __calc_kin_energy () self . __w_kin_min1 = self . __calc_kin_energy () self . __vis_damp = True self . __x_min1 = np . zeros ( self . __n , ) self . __x_min2 = np . zeros ( self . __n , ) return def __str__ ( self ): print ( \"ParticleSystem object instantiated with attributes \\n Connectivity matrix:\" ) print ( self . __connectivity_matrix ) print ( \"Instantiated particles:\" ) n = 1 for particle in self . __particles : print ( f \" p { n } : \" , particle ) n += 1 return \"\" def __instantiate_particles ( self , initial_conditions : list ): for set_of_initial_cond in initial_conditions : x = set_of_initial_cond [ 0 ] v = set_of_initial_cond [ 1 ] m = set_of_initial_cond [ 2 ] f = set_of_initial_cond [ 3 ] if f and len ( set_of_initial_cond ) >= 5 : con = set_of_initial_cond [ 4 ] con_t = set_of_initial_cond [ 5 ] self . __particles . append ( Particle ( x , v , m , f , con , con_t )) else : self . __particles . append ( Particle ( x , v , m , f )) return def __instantiate_springdampers ( self ): for link in self . __connectivity_matrix : link = link . copy () #needed to not override the __connectivity_matrix link [ 0 ] = self . __particles [ link [ 0 ]] link [ 1 ] = self . __particles [ link [ 1 ]] self . __springdampers . append ( SpringDamper ( * link )) return def stress_self ( self , factor : float = 0 ): \"\"\"Set all node lengths to zero to homogenously stress mesh\"\"\" if factor == 0 : for link in self . springdampers : link . l0 = 0 else : for link in self . springdampers : link . l0 *= factor return def __construct_m_matrix ( self ): matrix = np . zeros (( self . __n * 3 , self . __n * 3 )) for i in range ( self . __n ): matrix [ i * 3 : i * 3 + 3 , i * 3 : i * 3 + 3 ] += np . identity ( 3 ) * self . __particles [ i ] . m return matrix def __calc_kin_energy ( self ): v = self . __pack_v_current () w_kin = np . matmul ( np . matmul ( v , self . __m_matrix ), v . T ) # Kinetic energy, 0.5 constant can be neglected return w_kin def simulate ( self , f_external : npt . ArrayLike = ()): if not len ( f_external ): # check if external force is passed as argument, otherwise use 0 vector f_external = np . zeros ( self . __n * 3 , ) f = self . __one_d_force_vector () + f_external v_current = self . __pack_v_current () x_current = self . __pack_x_current () jx , jv = self . __system_jacobians () #jx = scipy.sparse.lil_array(jx) #jv = scipy.sparse.lil_array(jv) # constructing A matrix and b vector for solver A = self . __m_matrix - self . __dt * jv - self . __dt ** 2 * jx b = self . __dt * f + self . __dt ** 2 * jx . dot ( v_current ) # checking conditioning of A # print(\"conditioning A:\", np.linalg.cond(A)) #A = scipy.sparse.bsr_array(A) # BiCGSTAB from scipy library dv , _ = bicgstab ( A , b , tol = self . __rtol , atol = self . __atol , maxiter = self . __maxiter ) # numerical time integration following implicit Euler scheme v_next = v_current + dv x_next = x_current + self . __dt * v_next # function returns the pos. and vel. for the next timestep, but for fixed particles this value doesn't update! self . __update_x_v ( x_next , v_next ) return x_next , v_next def kin_damp_sim ( self , f_ext : npt . ArrayLike = (), q_correction : bool = False ): # kinetic damping algorithm if self . __vis_damp : # Condition resetting viscous damping to 0 for link in self . __springdampers : link . c = 0 self . __c = 0 self . __vis_damp = False if len ( f_ext ): # condition checking if an f_ext is passed as argument self . __save_state () x_next , v_next = self . simulate ( f_ext ) else : self . __save_state () x_next , v_next = self . simulate () w_kin_new = self . __calc_kin_energy () if w_kin_new > self . __w_kin : # kin damping algorithm, takes effect when decrease in kin energy is detected self . __update_w_kin ( w_kin_new ) else : v_next = np . zeros ( self . __n * 3 , ) if q_correction : # statement to check if q_correction is desired, standard is turned off q = ( self . __w_kin - w_kin_new ) / ( 2 * self . __w_kin - self . __w_kin_min1 - w_kin_new ) # print(q) # print(self.__w_kin, w_kin_new) # !!! Not sure if linear interpolation between states is the way to determine new x_next !!! if q < 0.5 : x_next = self . __x_min2 + ( q / 0.5 ) * ( self . __x_min1 - self . __x_min2 ) elif q == 0.5 : x_next = self . __x_min1 elif q < 1 : x_next = self . __x_min1 + (( q - 0.5 ) / 0.5 ) * ( x_next - self . __x_min1 ) # Can also use this q factor to recalculate the state for certain timestep h self . __update_x_v ( x_next , v_next ) self . __update_w_kin ( 0 ) return x_next , v_next def __pack_v_current ( self ): return np . array ([ particle . v for particle in self . __particles ]) . flatten () def __pack_x_current ( self ): return np . array ([ particle . x for particle in self . __particles ]) . flatten () def __one_d_force_vector ( self ): self . __f [ self . __f != 0 ] = 0 for n in range ( len ( self . __springdampers )): f_int = self . __springdampers [ n ] . force_value () i , j , * _ = self . __connectivity_matrix [ n ] self . __f [ i * 3 : i * 3 + 3 ] += f_int self . __f [ j * 3 : j * 3 + 3 ] -= f_int return self . __f def __system_jacobians ( self ): self . __jx [ self . __jx != 0 ] = 0 self . __jv [ self . __jv != 0 ] = 0 for n in range ( len ( self . __springdampers )): jx , jv = self . __springdampers [ n ] . calculate_jacobian () i , j , * _ = self . __connectivity_matrix [ n ] if self . __particles [ i ] . fixed : if self . __particles [ i ] . constraint_type == 'point' : jxplus = np . zeros ([ 3 , 3 ]) jvplus = jxplus else : jxplus = self . __particles [ i ] . constraint_projection_matrix . dot ( jx ) jvplus = self . __particles [ i ] . constraint_projection_matrix . dot ( jv ) else : jxplus = jx jvplus = jv if self . __particles [ j ] . fixed : if self . __particles [ j ] . constraint_type == 'point' : jxmin = np . zeros ([ 3 , 3 ]) jvmin = jxmin else : jxmin = self . __particles [ j ] . constraint_projection_matrix . dot ( jx ) jvmin = self . __particles [ j ] . constraint_projection_matrix . dot ( jv ) else : jxmin = jx jvmin = jv self . __jx [ i * 3 : i * 3 + 3 , i * 3 : i * 3 + 3 ] += jxplus self . __jx [ j * 3 : j * 3 + 3 , j * 3 : j * 3 + 3 ] += jxplus self . __jx [ i * 3 : i * 3 + 3 , j * 3 : j * 3 + 3 ] -= jxmin self . __jx [ j * 3 : j * 3 + 3 , i * 3 : i * 3 + 3 ] -= jxmin self . __jv [ i * 3 : i * 3 + 3 , i * 3 : i * 3 + 3 ] += jvplus self . __jv [ j * 3 : j * 3 + 3 , j * 3 : j * 3 + 3 ] += jvplus self . __jv [ i * 3 : i * 3 + 3 , j * 3 : j * 3 + 3 ] -= jvmin self . __jv [ j * 3 : j * 3 + 3 , i * 3 : i * 3 + 3 ] -= jvmin return self . __jx , self . __jv def __update_x_v ( self , x_next : npt . ArrayLike , v_next : npt . ArrayLike ): for i in range ( self . __n ): self . __particles [ i ] . update_pos ( x_next [ i * 3 : i * 3 + 3 ]) self . __particles [ i ] . update_vel ( v_next [ i * 3 : i * 3 + 3 ]) return def __update_w_kin ( self , w_kin_new : float ): self . __w_kin_min1 = self . __w_kin self . __w_kin = w_kin_new return def __save_state ( self ): self . __x_min2 = self . __x_min1 self . __x_min1 = self . __pack_x_current () return def find_reaction_forces ( self ): fixlist = [ p . fixed for p in self . particles ] projections = [ p . constraint_projection_matrix for p in np . array ( self . particles )[ fixlist ]] forces = self . __f . reshape (( self . __n , 3 )) forces = - forces [ fixlist ] for i , projection in enumerate ( projections ): forces [ i ] -= projection . dot ( forces [ i ] . T ) . T return forces @property def particles ( self ): # @property decorators required, as PS info might be required for external calcs return self . __particles @property def springdampers ( self ): return self . __springdampers # @property # def stiffness_m(self): # self.__system_jacobians() # return self.__jx @property def kinetic_energy ( self ): return self . __w_kin @property def f_int ( self ): f_int = self . __f . copy () for i in range ( len ( self . __particles )): # need to exclude fixed particles for force-based convergence if self . __particles [ i ] . fixed : f_int [ i * 3 :( i + 1 ) * 3 ] = 0 return f_int @property def x_v_current ( self ): return self . __pack_x_current (), self . __pack_v_current () @property def x_v_current_3D ( self ): x = self . __pack_x_current () v = self . __pack_v_current () x = np . reshape ( x , ( int ( len ( x ) / 3 ), 3 )) v = np . reshape ( v , ( int ( len ( v ) / 3 ), 3 )) return x , v def plot ( self ): \"\"\"\"Plots current system configuration # TODO matplotlib styleguide recommends that helper functions take ax as an argument \"\"\" fig = plt . figure () ax = fig . add_subplot ( projection = '3d' ) fixlist = [] freelist = [] for particle in self . __particles : if particle . fixed : fixlist . append ( particle . x ) else : freelist . append ( particle . x ) fixlist = np . array ( fixlist ) freelist = np . array ( freelist ) ax . scatter ( fixlist [:, 0 ], fixlist [:, 1 ], fixlist [:, 2 ], color = 'red' , marker = 'o' ) ax . scatter ( freelist [:, 0 ], freelist [:, 1 ], freelist [:, 2 ], color = 'blue' , marker = 'o' , s = 5 ) segments = [] for link in self . __springdampers : segments . append ( link . line_segment ()) lc = Line3DCollection ( segments , colors = 'black' , linewidths = 0.5 ) ax . add_collection3d ( lc ) ax . set_xlabel ( 'x' ) ax . set_ylabel ( 'y' ) ax . set_zlabel ( 'z' ) ax . set_aspect ( 'equal' ) return ax def initialize_find_surface ( self , projection_plane : str = 'z' ): \"\"\" performs triangulation and sets up conversion matrix for surface calc Projects the point cloud onto specified plane and performs triangulation. Then uses shape of current triangles to create a conversion matrix for assigning the areas of each triangle onto the nodes. Parameters ---------- projection_plane : str normal direction of plane for the mesh to be projected on for triangulation. Default: z Returns ------- simplices : list nested list of node indices that make up triangles conversion_matrix : npt.ArrayLike ndarray of shape n_nodes x n_triangles \"\"\" # Gathering points of nodes points = self . __pack_x_current () points = points . reshape (( int ( len ( points ) / 3 ), 3 )) # Checking projection plane if projection_plane == 'x' : projection_plane = 0 elif projection_plane == 'y' : projection_plane = 1 elif projection_plane == 'z' : projection_plane = 2 else : raise AttributeError ( \"projection_plane improperly defined; Must be x, y or z.\" ) # Performing triangulation points_projected = points [:,: projection_plane ] # Projecting onto x-y plane tri = Delaunay ( points_projected ) # Finding areas of each triangle v1 = points [ tri . simplices ][:, 0 ] - points [ tri . simplices ][:, 1 ] v2 = points [ tri . simplices ][:, 0 ] - points [ tri . simplices ][:, 2 ] # Next we set up the matrix multiplication that will divide the areas # of the triangles over the actual nodes conversion_matrix = np . zeros (( self . __n * 3 , len ( tri . simplices ) * 3 )) v1_length = np . linalg . norm ( v1 , axis = 1 ) v2_length = np . linalg . norm ( v2 , axis = 1 ) v3_length = np . linalg . norm ( v2 - v1 , axis = 1 ) angle_1 = np . arccos ( np . sum ( v1 * v2 , axis = 1 ) / ( v1_length * v2_length )) angle_2 = np . arcsin ( v2_length / v3_length * np . sin ( angle_1 )) angle_3 = np . pi - angle_1 - angle_2 angle_iterator = np . column_stack (( angle_1 , angle_2 , angle_3 )) . flatten () / np . pi for j , indices in enumerate ( tri . simplices ): for k , i in enumerate ( indices ): conversion_matrix [ 3 * i , 3 * j ] += angle_iterator [ 3 * j + k ] conversion_matrix [ 3 * i + 1 , 3 * j + 1 ] += angle_iterator [ 3 * j + k ] conversion_matrix [ 3 * i + 2 , 3 * j + 2 ] += angle_iterator [ 3 * j + k ] return tri . simplices , conversion_matrix def find_surface ( self , projection_plane : str = 'z' ) -> np . ndarray : \"\"\" finds the surface area vector for each node in the mesh Parameters ---------- projection_plane: passed to self.initialize_find_surface(). Returns ------- areas: npt.ArrayLike 3D area vectors for each node \"\"\" if not hasattr ( self , '_ParticleSystem__surface_conversion_matrix' ): logging . warning ( 'find_surface called without prior initialization.' ) simplices , conversion_matrix = self . initialize_find_surface () self . __simplices = simplices self . __surface_conversion_matrix = conversion_matrix else : conversion_matrix = self . __surface_conversion_matrix simplices = self . __simplices # Gathering points of nodes points = self . __pack_x_current () points = points . reshape (( int ( len ( points ) / 3 ), 3 )) # Finding areas of each triangle v1 = points [ simplices ][:, 0 ] - points [ simplices ][:, 1 ] v2 = points [ simplices ][:, 0 ] - points [ simplices ][:, 2 ] area_vectors = np . cross ( v1 , v2 ) / 2 # Now we transorm the simplice areas into nodal areas input_vector = area_vectors . flatten () area_vectors_1d = np . matmul ( conversion_matrix , input_vector ) area_vectors_redistributed = area_vectors_1d . reshape (( self . __n , 3 )) return area_vectors_redistributed def plot_triangulated_surface ( self ): \"\"\" plots triangulated surface for user inspection \"\"\" # Gathering points of nodes points = self . __pack_x_current () points = points . reshape (( int ( len ( points ) / 3 ), 3 )) x , y , z = points [:, 0 ], points [:, 1 ], points [:, 2 ] area_vectors = self . find_surface () a_u = area_vectors [:, 0 ] a_v = area_vectors [:, 1 ] a_w = area_vectors [:, 2 ] fig = plt . figure () ax = fig . add_subplot ( projection = '3d' ) ax . plot_trisurf ( x , y , z , triangles = self . __simplices , cmap = plt . cm . Spectral ) ax . scatter ( x , y , z ) ax . quiver ( x , y , z , a_u , a_v , a_w , length = 1 ) return ax if __name__ == \"__main__\" : params = { # model parameters \"n\" : 3 , # [-] number of particles \"k\" : 2e4 , # [N/m] spring stiffness \"c\" : 0 , # [N s/m] damping coefficient \"l0\" : 0 , # [m] rest length # simulation settings \"dt\" : 0.001 , # [s] simulation timestep \"t_steps\" : 1000 , # [-] number of simulated time steps \"abs_tol\" : 1e-50 , # [m/s] absolute error tolerance iterative solver \"rel_tol\" : 1e-5 , # [-] relative error tolerance iterative solver \"max_iter\" : 1e5 , # [-] maximum number of iterations # physical parameters \"g\" : 9.81 # [m/s^2] gravitational acceleration } c_matrix = [[ 0 , 1 , params [ 'k' ], params [ 'c' ]], [ 1 , 2 , params [ 'k' ], params [ 'c' ]] ] init_cond = [[[ 0 , 0 , 0 ], [ 0 , 0 , 0 ], 1 , True ], [[ 1 , 0 , 0 ], [ 0 , 0 , 0 ], 1 , False ], [[ 1 , 1 , 0 ], [ 0 , 0 , 0 ], 1 , False ] ] ps = ParticleSystem ( c_matrix , init_cond , params ) print ( ps ) ps . plot () pass Classes ParticleSystem class ParticleSystem ( connectivity_matrix : list , initial_conditions : Union [ numpy . __array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . __nested_sequence . _NestedSequence [ numpy . __array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . __nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], sim_param : dict ) View Source class ParticleSystem : def __init__ ( self , connectivity_matrix : list , initial_conditions : npt . ArrayLike , sim_param : dict ) : \"\"\" Constructor for ParticleSystem object, model made up of n particles Parameters --------- connectivity_matrix : list 2-by-m matrix, where each column contains a nodal index pair that is connectedby a spring element. initial_conditions : npt.ArrayLike Array of n arrays to instantiate particles. Each subarray must contain the params required for the particle constructor: [initial_pos, initial_vel, mass, fixed: bool, constraint] param sim_param : dict Dictionary of other parameters required for simulation (dt, rtol, ...) \"\"\" self . __connectivity_matrix = connectivity_matrix self . __n = len ( initial_conditions ) self . __dt = sim_param [ \"dt\" ] self . __rtol = sim_param [ \"rel_tol\" ] self . __atol = sim_param [ \"abs_tol\" ] self . __maxiter = sim_param [ \"max_iter\" ] # allocate memory self . __particles = [] self . __springdampers = [] self . __f = np . zeros (( self . __n * 3 , )) self . __jx = np . zeros (( self . __n * 3 , self . __n * 3 )) self . __jv = np . zeros (( self . __n * 3 , self . __n * 3 )) self . __instantiate_particles ( initial_conditions ) self . __m_matrix = self . __construct_m_matrix () self . __instantiate_springdampers () # Variables required for kinetic damping self . __w_kin = self . __calc_kin_energy () self . __w_kin_min1 = self . __calc_kin_energy () self . __vis_damp = True self . __x_min1 = np . zeros ( self . __n , ) self . __x_min2 = np . zeros ( self . __n , ) return def __str__ ( self ) : print ( \"ParticleSystem object instantiated with attributes\\nConnectivity matrix:\" ) print ( self . __connectivity_matrix ) print ( \"Instantiated particles:\" ) n = 1 for particle in self . __particles : print ( f \" p{n}: \" , particle ) n += 1 return \"\" def __instantiate_particles ( self , initial_conditions : list ) : for set_of_initial_cond in initial_conditions : x = set_of_initial_cond [ 0 ] v = set_of_initial_cond [ 1 ] m = set_of_initial_cond [ 2 ] f = set_of_initial_cond [ 3 ] if f and len ( set_of_initial_cond ) >= 5 : con = set_of_initial_cond [ 4 ] con_t = set_of_initial_cond [ 5 ] self . __particles . append ( Particle ( x , v , m , f , con , con_t )) else : self . __particles . append ( Particle ( x , v , m , f )) return def __instantiate_springdampers ( self ) : for link in self . __connectivity_matrix : link = link . copy () #needed to not override the __connectivity_matrix link [ 0 ] = self . __particles [ link[0 ] ] link [ 1 ] = self . __particles [ link[1 ] ] self . __springdampers . append ( SpringDamper ( * link )) return def stress_self ( self , factor : float = 0 ) : \"\"\"Set all node lengths to zero to homogenously stress mesh\"\"\" if factor == 0 : for link in self . springdampers : link . l0 = 0 else : for link in self . springdampers : link . l0 *= factor return def __construct_m_matrix ( self ) : matrix = np . zeros (( self . __n * 3 , self . __n * 3 )) for i in range ( self . __n ) : matrix [ i*3:i*3+3, i*3:i*3+3 ] += np . identity ( 3 ) * self . __particles [ i ] . m return matrix def __calc_kin_energy ( self ) : v = self . __pack_v_current () w_kin = np . matmul ( np . matmul ( v , self . __m_matrix ), v . T ) # Kinetic energy , 0.5 constant can be neglected return w_kin def simulate ( self , f_external : npt . ArrayLike = ()) : if not len ( f_external ) : # check if external force is passed as argument , otherwise use 0 vector f_external = np . zeros ( self . __n * 3 , ) f = self . __one_d_force_vector () + f_external v_current = self . __pack_v_current () x_current = self . __pack_x_current () jx , jv = self . __system_jacobians () #jx = scipy . sparse . lil_array ( jx ) #jv = scipy . sparse . lil_array ( jv ) # constructing A matrix and b vector for solver A = self . __m_matrix - self . __dt * jv - self . __dt ** 2 * jx b = self . __dt * f + self . __dt ** 2 * jx . dot ( v_current ) # checking conditioning of A # print ( \"conditioning A:\" , np . linalg . cond ( A )) #A = scipy . sparse . bsr_array ( A ) # BiCGSTAB from scipy library dv , _ = bicgstab ( A , b , tol = self . __rtol , atol = self . __atol , maxiter = self . __maxiter ) # numerical time integration following implicit Euler scheme v_next = v_current + dv x_next = x_current + self . __dt * v_next # function returns the pos . and vel . for the next timestep , but for fixed particles this value doesn 't update! self.__update_x_v(x_next, v_next) return x_next, v_next def kin_damp_sim(self, f_ext: npt.ArrayLike = (), q_correction: bool = False): # kinetic damping algorithm if self.__vis_damp: # Condition resetting viscous damping to 0 for link in self.__springdampers: link.c = 0 self.__c = 0 self.__vis_damp = False if len(f_ext): # condition checking if an f_ext is passed as argument self.__save_state() x_next, v_next = self.simulate(f_ext) else: self.__save_state() x_next, v_next = self.simulate() w_kin_new = self.__calc_kin_energy() if w_kin_new > self.__w_kin: # kin damping algorithm, takes effect when decrease in kin energy is detected self.__update_w_kin(w_kin_new) else: v_next = np.zeros(self.__n*3, ) if q_correction: # statement to check if q_correction is desired, standard is turned off q = (self.__w_kin - w_kin_new)/(2*self.__w_kin - self.__w_kin_min1 - w_kin_new) # print(q) # print(self.__w_kin, w_kin_new) # !!! Not sure if linear interpolation between states is the way to determine new x_next !!! if q < 0.5: x_next = self.__x_min2 + (q / 0.5) * (self.__x_min1 - self.__x_min2) elif q == 0.5: x_next = self.__x_min1 elif q < 1: x_next = self.__x_min1 + ((q - 0.5) / 0.5) * (x_next - self.__x_min1) # Can also use this q factor to recalculate the state for certain timestep h self.__update_x_v(x_next, v_next) self.__update_w_kin(0) return x_next, v_next def __pack_v_current(self): return np.array([particle.v for particle in self.__particles]).flatten() def __pack_x_current(self): return np.array([particle.x for particle in self.__particles]).flatten() def __one_d_force_vector(self): self.__f[self.__f != 0] = 0 for n in range(len(self.__springdampers)): f_int = self.__springdampers[n].force_value() i, j, *_ = self.__connectivity_matrix[n] self.__f[i*3: i*3 + 3] += f_int self.__f[j*3: j*3 + 3] -= f_int return self.__f def __system_jacobians(self): self.__jx[self.__jx != 0] = 0 self.__jv[self.__jv != 0] = 0 for n in range(len(self.__springdampers)): jx, jv = self.__springdampers[n].calculate_jacobian() i, j, *_ = self.__connectivity_matrix[n] if self.__particles[i].fixed: if self.__particles[i].constraint_type == ' point ': jxplus = np.zeros([3,3]) jvplus = jxplus else: jxplus = self.__particles[i].constraint_projection_matrix.dot(jx) jvplus = self.__particles[i].constraint_projection_matrix.dot(jv) else: jxplus = jx jvplus = jv if self.__particles[j].fixed: if self.__particles[j].constraint_type == ' point ': jxmin = np.zeros([3,3]) jvmin = jxmin else: jxmin = self.__particles[j].constraint_projection_matrix.dot(jx) jvmin = self.__particles[j].constraint_projection_matrix.dot(jv) else: jxmin = jx jvmin = jv self.__jx[i * 3:i * 3 + 3, i * 3:i * 3 + 3] += jxplus self.__jx[j * 3:j * 3 + 3, j * 3:j * 3 + 3] += jxplus self.__jx[i * 3:i * 3 + 3, j * 3:j * 3 + 3] -= jxmin self.__jx[j * 3:j * 3 + 3, i * 3:i * 3 + 3] -= jxmin self.__jv[i * 3:i * 3 + 3, i * 3:i * 3 + 3] += jvplus self.__jv[j * 3:j * 3 + 3, j * 3:j * 3 + 3] += jvplus self.__jv[i * 3:i * 3 + 3, j * 3:j * 3 + 3] -= jvmin self.__jv[j * 3:j * 3 + 3, i * 3:i * 3 + 3] -= jvmin return self.__jx, self.__jv def __update_x_v(self, x_next: npt.ArrayLike, v_next: npt.ArrayLike): for i in range(self.__n): self.__particles[i].update_pos(x_next[i * 3:i * 3 + 3]) self.__particles[i].update_vel(v_next[i * 3:i * 3 + 3]) return def __update_w_kin(self, w_kin_new: float): self.__w_kin_min1 = self.__w_kin self.__w_kin = w_kin_new return def __save_state(self): self.__x_min2 = self.__x_min1 self.__x_min1 = self.__pack_x_current() return def find_reaction_forces(self): fixlist = [p.fixed for p in self.particles] projections = [p.constraint_projection_matrix for p in np.array(self.particles)[fixlist]] forces = self.__f.reshape((self.__n,3)) forces = -forces[fixlist] for i, projection in enumerate(projections): forces[i] -= projection.dot(forces[i].T).T return forces @property def particles(self): # @property decorators required, as PS info might be required for external calcs return self.__particles @property def springdampers(self): return self.__springdampers # @property # def stiffness_m(self): # self.__system_jacobians() # return self.__jx @property def kinetic_energy(self): return self.__w_kin @property def f_int(self): f_int = self.__f.copy() for i in range(len(self.__particles)): # need to exclude fixed particles for force-based convergence if self.__particles[i].fixed: f_int[i*3:(i+1)*3] = 0 return f_int @property def x_v_current(self): return self.__pack_x_current(), self.__pack_v_current() @property def x_v_current_3D(self): x = self.__pack_x_current() v = self.__pack_v_current() x = np.reshape(x, (int(len(x)/3),3)) v = np.reshape(v, (int(len(v)/3),3)) return x, v def plot(self): \"\"\"\"Plots current system configuration # TODO matplotlib styleguide recommends that helper functions take ax as an argument \"\"\" fig = plt.figure() ax = fig.add_subplot(projection=' 3 d ') fixlist = [] freelist = [] for particle in self.__particles: if particle.fixed: fixlist.append(particle.x) else: freelist.append(particle.x) fixlist = np.array(fixlist) freelist = np.array(freelist) ax.scatter(fixlist[:,0],fixlist[:,1],fixlist[:,2], color = ' red ', marker = ' o ') ax.scatter(freelist[:,0],freelist[:,1],freelist[:,2], color = ' blue ', marker = ' o ', s =5) segments = [] for link in self.__springdampers: segments.append(link.line_segment()) lc = Line3DCollection(segments, colors = ' black ', linewidths = 0.5) ax.add_collection3d(lc) ax.set_xlabel(' x ') ax.set_ylabel(' y ') ax.set_zlabel(' z ') ax.set_aspect(' equal ') return ax def initialize_find_surface(self, projection_plane: str = ' z '): \"\"\" performs triangulation and sets up conversion matrix for surface calc Projects the point cloud onto specified plane and performs triangulation. Then uses shape of current triangles to create a conversion matrix for assigning the areas of each triangle onto the nodes. Parameters ---------- projection_plane : str normal direction of plane for the mesh to be projected on for triangulation. Default: z Returns ------- simplices : list nested list of node indices that make up triangles conversion_matrix : npt.ArrayLike ndarray of shape n_nodes x n_triangles \"\"\" # Gathering points of nodes points = self.__pack_x_current() points = points.reshape((int(len(points)/3),3)) # Checking projection plane if projection_plane == ' x ': projection_plane = 0 elif projection_plane == ' y ': projection_plane = 1 elif projection_plane == ' z ': projection_plane = 2 else: raise AttributeError(\"projection_plane improperly defined; Must be x, y or z.\") # Performing triangulation points_projected = points[:,:projection_plane] # Projecting onto x-y plane tri = Delaunay(points_projected) # Finding areas of each triangle v1 = points[tri.simplices][:,0]-points[tri.simplices][:,1] v2 = points[tri.simplices][:,0]-points[tri.simplices][:,2] # Next we set up the matrix multiplication that will divide the areas # of the triangles over the actual nodes conversion_matrix = np.zeros((self.__n*3,len(tri.simplices)*3)) v1_length = np.linalg.norm(v1, axis=1) v2_length = np.linalg.norm(v2, axis=1) v3_length = np.linalg.norm(v2-v1, axis=1) angle_1 = np.arccos(np.sum(v1*v2, axis = 1)/(v1_length*v2_length)) angle_2 = np.arcsin(v2_length/v3_length * np.sin(angle_1)) angle_3 = np.pi - angle_1 - angle_2 angle_iterator = np.column_stack((angle_1, angle_2, angle_3)).flatten()/np.pi for j, indices in enumerate(tri.simplices): for k, i in enumerate(indices): conversion_matrix[3*i,3*j]+= angle_iterator[3*j+k] conversion_matrix[3*i+1,3*j+1]+= angle_iterator[3*j+k] conversion_matrix[3*i+2,3*j+2]+= angle_iterator[3*j+k] return tri.simplices, conversion_matrix def find_surface(self, projection_plane: str = ' z ') -> np.ndarray: \"\"\" finds the surface area vector for each node in the mesh Parameters ---------- projection_plane: passed to self.initialize_find_surface(). Returns ------- areas: npt.ArrayLike 3D area vectors for each node \"\"\" if not hasattr(self, ' _ParticleSystem__surface_conversion_matrix '): logging.warning(' find_surface called without prior initialization . ') simplices, conversion_matrix = self.initialize_find_surface() self.__simplices = simplices self.__surface_conversion_matrix = conversion_matrix else: conversion_matrix = self.__surface_conversion_matrix simplices = self.__simplices # Gathering points of nodes points = self.__pack_x_current() points = points.reshape((int(len(points)/3),3)) # Finding areas of each triangle v1 = points[simplices][:,0]-points[simplices][:,1] v2 = points[simplices][:,0]-points[simplices][:,2] area_vectors = np.cross(v1,v2)/2 # Now we transorm the simplice areas into nodal areas input_vector = area_vectors.flatten() area_vectors_1d = np.matmul(conversion_matrix,input_vector) area_vectors_redistributed = area_vectors_1d.reshape((self.__n,3)) return area_vectors_redistributed def plot_triangulated_surface(self): \"\"\" plots triangulated surface for user inspection \"\"\" # Gathering points of nodes points = self.__pack_x_current() points = points.reshape((int(len(points)/3),3)) x,y,z = points[:,0], points[:,1], points[:,2] area_vectors = self.find_surface() a_u = area_vectors[:,0] a_v = area_vectors[:,1] a_w = area_vectors[:,2] fig = plt.figure() ax = fig.add_subplot(projection=' 3 d ' ) ax . plot_trisurf ( x , y , z , triangles = self . __simplices , cmap = plt . cm . Spectral ) ax . scatter ( x , y , z ) ax . quiver ( x , y , z , a_u , a_v , a_w , length = 1 ) return ax Instance variables f_int kinetic_energy particles springdampers x_v_current x_v_current_3D Methods find_reaction_forces def find_reaction_forces ( self ) View Source def find_reaction_forces ( self ) : fixlist = [ p.fixed for p in self.particles ] projections = [ p.constraint_projection_matrix for p in np.array(self.particles)[fixlist ] ] forces = self . __f . reshape (( self . __n , 3 )) forces = - forces [ fixlist ] for i , projection in enumerate ( projections ) : forces [ i ] -= projection . dot ( forces [ i ] . T ). T return forces find_surface def find_surface ( self , projection_plane : str = 'z' ) -> numpy . ndarray finds the surface area vector for each node in the mesh Returns: Type Description npt.ArrayLike 3D area vectors for each node View Source def find_surface ( self , projection_plane : str = 'z' ) -> np . ndarray : \"\"\" finds the surface area vector for each node in the mesh Parameters ---------- projection_plane: passed to self.initialize_find_surface(). Returns ------- areas: npt.ArrayLike 3D area vectors for each node \"\"\" if not hasattr ( self , '_ParticleSystem__surface_conversion_matrix' ) : logging . warning ( 'find_surface called without prior initialization.' ) simplices , conversion_matrix = self . initialize_find_surface () self . __simplices = simplices self . __surface_conversion_matrix = conversion_matrix else : conversion_matrix = self . __surface_conversion_matrix simplices = self . __simplices # Gathering points of nodes points = self . __pack_x_current () points = points . reshape (( int ( len ( points ) / 3 ), 3 )) # Finding areas of each triangle v1 = points [ simplices ][ :,0 ]- points [ simplices ][ :,1 ] v2 = points [ simplices ][ :,0 ]- points [ simplices ][ :,2 ] area_vectors = np . cross ( v1 , v2 ) / 2 # Now we transorm the simplice areas into nodal areas input_vector = area_vectors . flatten () area_vectors_1d = np . matmul ( conversion_matrix , input_vector ) area_vectors_redistributed = area_vectors_1d . reshape (( self . __n , 3 )) return area_vectors_redistributed initialize_find_surface def initialize_find_surface ( self , projection_plane : str = 'z' ) performs triangulation and sets up conversion matrix for surface calc Projects the point cloud onto specified plane and performs triangulation. Then uses shape of current triangles to create a conversion matrix for assigning the areas of each triangle onto the nodes. Parameters: Name Type Description Default projection_plane str normal direction of plane for the mesh to be projected on for triangulation. Default: z z Returns: Type Description list nested list of node indices that make up triangles View Source def initialize_find_surface ( self , projection_plane : str = 'z' ): \"\"\" performs triangulation and sets up conversion matrix for surface calc Projects the point cloud onto specified plane and performs triangulation. Then uses shape of current triangles to create a conversion matrix for assigning the areas of each triangle onto the nodes. Parameters ---------- projection_plane : str normal direction of plane for the mesh to be projected on for triangulation. Default: z Returns ------- simplices : list nested list of node indices that make up triangles conversion_matrix : npt.ArrayLike ndarray of shape n_nodes x n_triangles \"\"\" # Gathering points of nodes points = self . __pack_x_current () points = points . reshape (( int ( len ( points ) / 3 ), 3 )) # Checking projection plane if projection_plane == 'x' : projection_plane = 0 elif projection_plane == 'y' : projection_plane = 1 elif projection_plane == 'z' : projection_plane = 2 else : raise AttributeError ( \"projection_plane improperly defined; Must be x, y or z.\" ) # Performing triangulation points_projected = points [:,: projection_plane ] # Projecting onto x-y plane tri = Delaunay ( points_projected ) # Finding areas of each triangle v1 = points [ tri . simplices ][:, 0 ] - points [ tri . simplices ][:, 1 ] v2 = points [ tri . simplices ][:, 0 ] - points [ tri . simplices ][:, 2 ] # Next we set up the matrix multiplication that will divide the areas # of the triangles over the actual nodes conversion_matrix = np . zeros (( self . __n * 3 , len ( tri . simplices ) * 3 )) v1_length = np . linalg . norm ( v1 , axis = 1 ) v2_length = np . linalg . norm ( v2 , axis = 1 ) v3_length = np . linalg . norm ( v2 - v1 , axis = 1 ) angle_1 = np . arccos ( np . sum ( v1 * v2 , axis = 1 ) / ( v1_length * v2_length )) angle_2 = np . arcsin ( v2_length / v3_length * np . sin ( angle_1 )) angle_3 = np . pi - angle_1 - angle_2 angle_iterator = np . column_stack (( angle_1 , angle_2 , angle_3 )) . flatten () / np . pi for j , indices in enumerate ( tri . simplices ): for k , i in enumerate ( indices ): conversion_matrix [ 3 * i , 3 * j ] += angle_iterator [ 3 * j + k ] conversion_matrix [ 3 * i + 1 , 3 * j + 1 ] += angle_iterator [ 3 * j + k ] conversion_matrix [ 3 * i + 2 , 3 * j + 2 ] += angle_iterator [ 3 * j + k ] return tri . simplices , conversion_matrix kin_damp_sim def kin_damp_sim ( self , f_ext : Union [ numpy . __array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . __nested_sequence . _NestedSequence [ numpy . __array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . __nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = (), q_correction : bool = False ) View Source def kin_damp_sim ( self , f_ext : npt . ArrayLike = () , q_correction : bool = False ) : # kinetic damping algorithm if self . __vis_damp : # Condition resetting viscous damping to 0 for link in self . __springdampers : link . c = 0 self . __c = 0 self . __vis_damp = False if len ( f_ext ) : # condition checking if an f_ext is passed as argument self . __save_state () x_next , v_next = self . simulate ( f_ext ) else : self . __save_state () x_next , v_next = self . simulate () w_kin_new = self . __calc_kin_energy () if w_kin_new > self . __w_kin : # kin damping algorithm , takes effect when decrease in kin energy is detected self . __update_w_kin ( w_kin_new ) else : v_next = np . zeros ( self . __n * 3 , ) if q_correction : # statement to check if q_correction is desired , standard is turned off q = ( self . __w_kin - w_kin_new ) / ( 2 * self . __w_kin - self . __w_kin_min1 - w_kin_new ) # print ( q ) # print ( self . __w_kin , w_kin_new ) # !!! Not sure if linear interpolation between states is the way to determine new x_next !!! if q < 0 . 5 : x_next = self . __x_min2 + ( q / 0 . 5 ) * ( self . __x_min1 - self . __x_min2 ) elif q == 0 . 5 : x_next = self . __x_min1 elif q < 1 : x_next = self . __x_min1 + (( q - 0 . 5 ) / 0 . 5 ) * ( x_next - self . __x_min1 ) # Can also use this q factor to recalculate the state for certain timestep h self . __update_x_v ( x_next , v_next ) self . __update_w_kin ( 0 ) return x_next , v_next plot def plot ( self ) \"Plots current system configuration TODO matplotlib styleguide recommends that helper functions take ax as an argument View Source def plot ( self ) : \"\"\"\" Plots current system configuration # TODO matplotlib styleguide recommends that helper functions take ax as an argument \"\" \" fig = plt.figure() ax = fig.add_subplot(projection='3d') fixlist = [] freelist = [] for particle in self.__particles: if particle.fixed: fixlist.append(particle.x) else: freelist.append(particle.x) fixlist = np.array(fixlist) freelist = np.array(freelist) ax.scatter(fixlist[:,0],fixlist[:,1],fixlist[:,2], color = 'red', marker = 'o') ax.scatter(freelist[:,0],freelist[:,1],freelist[:,2], color = 'blue', marker = 'o', s =5) segments = [] for link in self.__springdampers: segments.append(link.line_segment()) lc = Line3DCollection(segments, colors = 'black', linewidths = 0.5) ax.add_collection3d(lc) ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('z') ax.set_aspect('equal') return ax plot_triangulated_surface def plot_triangulated_surface ( self ) plots triangulated surface for user inspection View Source def plot_triangulated_surface ( self ): \"\"\" plots triangulated surface for user inspection \"\"\" # Gathering points of nodes points = self . __pack_x_current () points = points . reshape (( int ( len ( points ) / 3 ), 3 )) x , y , z = points [:, 0 ], points [:, 1 ], points [:, 2 ] area_vectors = self . find_surface () a_u = area_vectors [:, 0 ] a_v = area_vectors [:, 1 ] a_w = area_vectors [:, 2 ] fig = plt . figure () ax = fig . add_subplot ( projection = ' 3 d ' ) ax . plot_trisurf ( x , y , z , triangles = self . __simplices , cmap = plt . cm . Spectral ) ax . scatter ( x , y , z ) ax . quiver ( x , y , z , a_u , a_v , a_w , length = 1 ) return ax simulate def simulate ( self , f_external : Union [ numpy . __array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . __nested_sequence . _NestedSequence [ numpy . __array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . __nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = () ) View Source def simulate ( self , f_external : npt . ArrayLike = ()): if not len ( f_external ): # check if external force is passed as argument , otherwise use 0 vector f_external = np . zeros ( self . __n * 3 , ) f = self . __one_d_force_vector () + f_external v_current = self . __pack_v_current () x_current = self . __pack_x_current () jx , jv = self . __system_jacobians () # jx = scipy . sparse . lil_array ( jx ) # jv = scipy . sparse . lil_array ( jv ) # constructing A matrix and b vector for solver A = self . __m_matrix - self . __dt * jv - self . __dt ** 2 * jx b = self . __dt * f + self . __dt ** 2 * jx . dot ( v_current ) # checking conditioning of A # print ( \"conditioning A:\" , np . linalg . cond ( A )) # A = scipy . sparse . bsr_array ( A ) # BiCGSTAB from scipy library dv , _ = bicgstab ( A , b , tol = self . __rtol , atol = self . __atol , maxiter = self . __maxiter ) # numerical time integration following implicit Euler scheme v_next = v_current + dv x_next = x_current + self . __dt * v_next # function returns the pos . and vel . for the next timestep , but for fixed particles this value doesn ' t update ! self . __update_x_v ( x_next , v_next ) return x_next , v_next stress_self def stress_self ( self , factor : float = 0 ) Set all node lengths to zero to homogenously stress mesh View Source def stress_self ( self , factor : float = 0 ) : \"\"\"Set all node lengths to zero to homogenously stress mesh\"\"\" if factor == 0 : for link in self . springdampers : link . l0 = 0 else : for link in self . springdampers : link . l0 *= factor return","title":"Particlesystem"},{"location":"reference/src/particleSystem/ParticleSystem/#module-srcparticlesystemparticlesystem","text":"ParticleSystem framework ... View Source \"\"\" ParticleSystem framework ... \"\"\" import logging import numpy as np import numpy.typing as npt from scipy.sparse.linalg import bicgstab import scipy.sparse from scipy.spatial import Delaunay import matplotlib.pyplot as plt from mpl_toolkits.mplot3d.art3d import Line3DCollection from src.particleSystem.Particle import Particle from src.particleSystem.SpringDamper import SpringDamper class ParticleSystem : def __init__ ( self , connectivity_matrix : list , initial_conditions : npt . ArrayLike , sim_param : dict ): \"\"\" Constructor for ParticleSystem object, model made up of n particles Parameters --------- connectivity_matrix : list 2-by-m matrix, where each column contains a nodal index pair that is connectedby a spring element. initial_conditions : npt.ArrayLike Array of n arrays to instantiate particles. Each subarray must contain the params required for the particle constructor: [initial_pos, initial_vel, mass, fixed: bool, constraint] param sim_param : dict Dictionary of other parameters required for simulation (dt, rtol, ...) \"\"\" self . __connectivity_matrix = connectivity_matrix self . __n = len ( initial_conditions ) self . __dt = sim_param [ \"dt\" ] self . __rtol = sim_param [ \"rel_tol\" ] self . __atol = sim_param [ \"abs_tol\" ] self . __maxiter = sim_param [ \"max_iter\" ] # allocate memory self . __particles = [] self . __springdampers = [] self . __f = np . zeros (( self . __n * 3 , )) self . __jx = np . zeros (( self . __n * 3 , self . __n * 3 )) self . __jv = np . zeros (( self . __n * 3 , self . __n * 3 )) self . __instantiate_particles ( initial_conditions ) self . __m_matrix = self . __construct_m_matrix () self . __instantiate_springdampers () # Variables required for kinetic damping self . __w_kin = self . __calc_kin_energy () self . __w_kin_min1 = self . __calc_kin_energy () self . __vis_damp = True self . __x_min1 = np . zeros ( self . __n , ) self . __x_min2 = np . zeros ( self . __n , ) return def __str__ ( self ): print ( \"ParticleSystem object instantiated with attributes \\n Connectivity matrix:\" ) print ( self . __connectivity_matrix ) print ( \"Instantiated particles:\" ) n = 1 for particle in self . __particles : print ( f \" p { n } : \" , particle ) n += 1 return \"\" def __instantiate_particles ( self , initial_conditions : list ): for set_of_initial_cond in initial_conditions : x = set_of_initial_cond [ 0 ] v = set_of_initial_cond [ 1 ] m = set_of_initial_cond [ 2 ] f = set_of_initial_cond [ 3 ] if f and len ( set_of_initial_cond ) >= 5 : con = set_of_initial_cond [ 4 ] con_t = set_of_initial_cond [ 5 ] self . __particles . append ( Particle ( x , v , m , f , con , con_t )) else : self . __particles . append ( Particle ( x , v , m , f )) return def __instantiate_springdampers ( self ): for link in self . __connectivity_matrix : link = link . copy () #needed to not override the __connectivity_matrix link [ 0 ] = self . __particles [ link [ 0 ]] link [ 1 ] = self . __particles [ link [ 1 ]] self . __springdampers . append ( SpringDamper ( * link )) return def stress_self ( self , factor : float = 0 ): \"\"\"Set all node lengths to zero to homogenously stress mesh\"\"\" if factor == 0 : for link in self . springdampers : link . l0 = 0 else : for link in self . springdampers : link . l0 *= factor return def __construct_m_matrix ( self ): matrix = np . zeros (( self . __n * 3 , self . __n * 3 )) for i in range ( self . __n ): matrix [ i * 3 : i * 3 + 3 , i * 3 : i * 3 + 3 ] += np . identity ( 3 ) * self . __particles [ i ] . m return matrix def __calc_kin_energy ( self ): v = self . __pack_v_current () w_kin = np . matmul ( np . matmul ( v , self . __m_matrix ), v . T ) # Kinetic energy, 0.5 constant can be neglected return w_kin def simulate ( self , f_external : npt . ArrayLike = ()): if not len ( f_external ): # check if external force is passed as argument, otherwise use 0 vector f_external = np . zeros ( self . __n * 3 , ) f = self . __one_d_force_vector () + f_external v_current = self . __pack_v_current () x_current = self . __pack_x_current () jx , jv = self . __system_jacobians () #jx = scipy.sparse.lil_array(jx) #jv = scipy.sparse.lil_array(jv) # constructing A matrix and b vector for solver A = self . __m_matrix - self . __dt * jv - self . __dt ** 2 * jx b = self . __dt * f + self . __dt ** 2 * jx . dot ( v_current ) # checking conditioning of A # print(\"conditioning A:\", np.linalg.cond(A)) #A = scipy.sparse.bsr_array(A) # BiCGSTAB from scipy library dv , _ = bicgstab ( A , b , tol = self . __rtol , atol = self . __atol , maxiter = self . __maxiter ) # numerical time integration following implicit Euler scheme v_next = v_current + dv x_next = x_current + self . __dt * v_next # function returns the pos. and vel. for the next timestep, but for fixed particles this value doesn't update! self . __update_x_v ( x_next , v_next ) return x_next , v_next def kin_damp_sim ( self , f_ext : npt . ArrayLike = (), q_correction : bool = False ): # kinetic damping algorithm if self . __vis_damp : # Condition resetting viscous damping to 0 for link in self . __springdampers : link . c = 0 self . __c = 0 self . __vis_damp = False if len ( f_ext ): # condition checking if an f_ext is passed as argument self . __save_state () x_next , v_next = self . simulate ( f_ext ) else : self . __save_state () x_next , v_next = self . simulate () w_kin_new = self . __calc_kin_energy () if w_kin_new > self . __w_kin : # kin damping algorithm, takes effect when decrease in kin energy is detected self . __update_w_kin ( w_kin_new ) else : v_next = np . zeros ( self . __n * 3 , ) if q_correction : # statement to check if q_correction is desired, standard is turned off q = ( self . __w_kin - w_kin_new ) / ( 2 * self . __w_kin - self . __w_kin_min1 - w_kin_new ) # print(q) # print(self.__w_kin, w_kin_new) # !!! Not sure if linear interpolation between states is the way to determine new x_next !!! if q < 0.5 : x_next = self . __x_min2 + ( q / 0.5 ) * ( self . __x_min1 - self . __x_min2 ) elif q == 0.5 : x_next = self . __x_min1 elif q < 1 : x_next = self . __x_min1 + (( q - 0.5 ) / 0.5 ) * ( x_next - self . __x_min1 ) # Can also use this q factor to recalculate the state for certain timestep h self . __update_x_v ( x_next , v_next ) self . __update_w_kin ( 0 ) return x_next , v_next def __pack_v_current ( self ): return np . array ([ particle . v for particle in self . __particles ]) . flatten () def __pack_x_current ( self ): return np . array ([ particle . x for particle in self . __particles ]) . flatten () def __one_d_force_vector ( self ): self . __f [ self . __f != 0 ] = 0 for n in range ( len ( self . __springdampers )): f_int = self . __springdampers [ n ] . force_value () i , j , * _ = self . __connectivity_matrix [ n ] self . __f [ i * 3 : i * 3 + 3 ] += f_int self . __f [ j * 3 : j * 3 + 3 ] -= f_int return self . __f def __system_jacobians ( self ): self . __jx [ self . __jx != 0 ] = 0 self . __jv [ self . __jv != 0 ] = 0 for n in range ( len ( self . __springdampers )): jx , jv = self . __springdampers [ n ] . calculate_jacobian () i , j , * _ = self . __connectivity_matrix [ n ] if self . __particles [ i ] . fixed : if self . __particles [ i ] . constraint_type == 'point' : jxplus = np . zeros ([ 3 , 3 ]) jvplus = jxplus else : jxplus = self . __particles [ i ] . constraint_projection_matrix . dot ( jx ) jvplus = self . __particles [ i ] . constraint_projection_matrix . dot ( jv ) else : jxplus = jx jvplus = jv if self . __particles [ j ] . fixed : if self . __particles [ j ] . constraint_type == 'point' : jxmin = np . zeros ([ 3 , 3 ]) jvmin = jxmin else : jxmin = self . __particles [ j ] . constraint_projection_matrix . dot ( jx ) jvmin = self . __particles [ j ] . constraint_projection_matrix . dot ( jv ) else : jxmin = jx jvmin = jv self . __jx [ i * 3 : i * 3 + 3 , i * 3 : i * 3 + 3 ] += jxplus self . __jx [ j * 3 : j * 3 + 3 , j * 3 : j * 3 + 3 ] += jxplus self . __jx [ i * 3 : i * 3 + 3 , j * 3 : j * 3 + 3 ] -= jxmin self . __jx [ j * 3 : j * 3 + 3 , i * 3 : i * 3 + 3 ] -= jxmin self . __jv [ i * 3 : i * 3 + 3 , i * 3 : i * 3 + 3 ] += jvplus self . __jv [ j * 3 : j * 3 + 3 , j * 3 : j * 3 + 3 ] += jvplus self . __jv [ i * 3 : i * 3 + 3 , j * 3 : j * 3 + 3 ] -= jvmin self . __jv [ j * 3 : j * 3 + 3 , i * 3 : i * 3 + 3 ] -= jvmin return self . __jx , self . __jv def __update_x_v ( self , x_next : npt . ArrayLike , v_next : npt . ArrayLike ): for i in range ( self . __n ): self . __particles [ i ] . update_pos ( x_next [ i * 3 : i * 3 + 3 ]) self . __particles [ i ] . update_vel ( v_next [ i * 3 : i * 3 + 3 ]) return def __update_w_kin ( self , w_kin_new : float ): self . __w_kin_min1 = self . __w_kin self . __w_kin = w_kin_new return def __save_state ( self ): self . __x_min2 = self . __x_min1 self . __x_min1 = self . __pack_x_current () return def find_reaction_forces ( self ): fixlist = [ p . fixed for p in self . particles ] projections = [ p . constraint_projection_matrix for p in np . array ( self . particles )[ fixlist ]] forces = self . __f . reshape (( self . __n , 3 )) forces = - forces [ fixlist ] for i , projection in enumerate ( projections ): forces [ i ] -= projection . dot ( forces [ i ] . T ) . T return forces @property def particles ( self ): # @property decorators required, as PS info might be required for external calcs return self . __particles @property def springdampers ( self ): return self . __springdampers # @property # def stiffness_m(self): # self.__system_jacobians() # return self.__jx @property def kinetic_energy ( self ): return self . __w_kin @property def f_int ( self ): f_int = self . __f . copy () for i in range ( len ( self . __particles )): # need to exclude fixed particles for force-based convergence if self . __particles [ i ] . fixed : f_int [ i * 3 :( i + 1 ) * 3 ] = 0 return f_int @property def x_v_current ( self ): return self . __pack_x_current (), self . __pack_v_current () @property def x_v_current_3D ( self ): x = self . __pack_x_current () v = self . __pack_v_current () x = np . reshape ( x , ( int ( len ( x ) / 3 ), 3 )) v = np . reshape ( v , ( int ( len ( v ) / 3 ), 3 )) return x , v def plot ( self ): \"\"\"\"Plots current system configuration # TODO matplotlib styleguide recommends that helper functions take ax as an argument \"\"\" fig = plt . figure () ax = fig . add_subplot ( projection = '3d' ) fixlist = [] freelist = [] for particle in self . __particles : if particle . fixed : fixlist . append ( particle . x ) else : freelist . append ( particle . x ) fixlist = np . array ( fixlist ) freelist = np . array ( freelist ) ax . scatter ( fixlist [:, 0 ], fixlist [:, 1 ], fixlist [:, 2 ], color = 'red' , marker = 'o' ) ax . scatter ( freelist [:, 0 ], freelist [:, 1 ], freelist [:, 2 ], color = 'blue' , marker = 'o' , s = 5 ) segments = [] for link in self . __springdampers : segments . append ( link . line_segment ()) lc = Line3DCollection ( segments , colors = 'black' , linewidths = 0.5 ) ax . add_collection3d ( lc ) ax . set_xlabel ( 'x' ) ax . set_ylabel ( 'y' ) ax . set_zlabel ( 'z' ) ax . set_aspect ( 'equal' ) return ax def initialize_find_surface ( self , projection_plane : str = 'z' ): \"\"\" performs triangulation and sets up conversion matrix for surface calc Projects the point cloud onto specified plane and performs triangulation. Then uses shape of current triangles to create a conversion matrix for assigning the areas of each triangle onto the nodes. Parameters ---------- projection_plane : str normal direction of plane for the mesh to be projected on for triangulation. Default: z Returns ------- simplices : list nested list of node indices that make up triangles conversion_matrix : npt.ArrayLike ndarray of shape n_nodes x n_triangles \"\"\" # Gathering points of nodes points = self . __pack_x_current () points = points . reshape (( int ( len ( points ) / 3 ), 3 )) # Checking projection plane if projection_plane == 'x' : projection_plane = 0 elif projection_plane == 'y' : projection_plane = 1 elif projection_plane == 'z' : projection_plane = 2 else : raise AttributeError ( \"projection_plane improperly defined; Must be x, y or z.\" ) # Performing triangulation points_projected = points [:,: projection_plane ] # Projecting onto x-y plane tri = Delaunay ( points_projected ) # Finding areas of each triangle v1 = points [ tri . simplices ][:, 0 ] - points [ tri . simplices ][:, 1 ] v2 = points [ tri . simplices ][:, 0 ] - points [ tri . simplices ][:, 2 ] # Next we set up the matrix multiplication that will divide the areas # of the triangles over the actual nodes conversion_matrix = np . zeros (( self . __n * 3 , len ( tri . simplices ) * 3 )) v1_length = np . linalg . norm ( v1 , axis = 1 ) v2_length = np . linalg . norm ( v2 , axis = 1 ) v3_length = np . linalg . norm ( v2 - v1 , axis = 1 ) angle_1 = np . arccos ( np . sum ( v1 * v2 , axis = 1 ) / ( v1_length * v2_length )) angle_2 = np . arcsin ( v2_length / v3_length * np . sin ( angle_1 )) angle_3 = np . pi - angle_1 - angle_2 angle_iterator = np . column_stack (( angle_1 , angle_2 , angle_3 )) . flatten () / np . pi for j , indices in enumerate ( tri . simplices ): for k , i in enumerate ( indices ): conversion_matrix [ 3 * i , 3 * j ] += angle_iterator [ 3 * j + k ] conversion_matrix [ 3 * i + 1 , 3 * j + 1 ] += angle_iterator [ 3 * j + k ] conversion_matrix [ 3 * i + 2 , 3 * j + 2 ] += angle_iterator [ 3 * j + k ] return tri . simplices , conversion_matrix def find_surface ( self , projection_plane : str = 'z' ) -> np . ndarray : \"\"\" finds the surface area vector for each node in the mesh Parameters ---------- projection_plane: passed to self.initialize_find_surface(). Returns ------- areas: npt.ArrayLike 3D area vectors for each node \"\"\" if not hasattr ( self , '_ParticleSystem__surface_conversion_matrix' ): logging . warning ( 'find_surface called without prior initialization.' ) simplices , conversion_matrix = self . initialize_find_surface () self . __simplices = simplices self . __surface_conversion_matrix = conversion_matrix else : conversion_matrix = self . __surface_conversion_matrix simplices = self . __simplices # Gathering points of nodes points = self . __pack_x_current () points = points . reshape (( int ( len ( points ) / 3 ), 3 )) # Finding areas of each triangle v1 = points [ simplices ][:, 0 ] - points [ simplices ][:, 1 ] v2 = points [ simplices ][:, 0 ] - points [ simplices ][:, 2 ] area_vectors = np . cross ( v1 , v2 ) / 2 # Now we transorm the simplice areas into nodal areas input_vector = area_vectors . flatten () area_vectors_1d = np . matmul ( conversion_matrix , input_vector ) area_vectors_redistributed = area_vectors_1d . reshape (( self . __n , 3 )) return area_vectors_redistributed def plot_triangulated_surface ( self ): \"\"\" plots triangulated surface for user inspection \"\"\" # Gathering points of nodes points = self . __pack_x_current () points = points . reshape (( int ( len ( points ) / 3 ), 3 )) x , y , z = points [:, 0 ], points [:, 1 ], points [:, 2 ] area_vectors = self . find_surface () a_u = area_vectors [:, 0 ] a_v = area_vectors [:, 1 ] a_w = area_vectors [:, 2 ] fig = plt . figure () ax = fig . add_subplot ( projection = '3d' ) ax . plot_trisurf ( x , y , z , triangles = self . __simplices , cmap = plt . cm . Spectral ) ax . scatter ( x , y , z ) ax . quiver ( x , y , z , a_u , a_v , a_w , length = 1 ) return ax if __name__ == \"__main__\" : params = { # model parameters \"n\" : 3 , # [-] number of particles \"k\" : 2e4 , # [N/m] spring stiffness \"c\" : 0 , # [N s/m] damping coefficient \"l0\" : 0 , # [m] rest length # simulation settings \"dt\" : 0.001 , # [s] simulation timestep \"t_steps\" : 1000 , # [-] number of simulated time steps \"abs_tol\" : 1e-50 , # [m/s] absolute error tolerance iterative solver \"rel_tol\" : 1e-5 , # [-] relative error tolerance iterative solver \"max_iter\" : 1e5 , # [-] maximum number of iterations # physical parameters \"g\" : 9.81 # [m/s^2] gravitational acceleration } c_matrix = [[ 0 , 1 , params [ 'k' ], params [ 'c' ]], [ 1 , 2 , params [ 'k' ], params [ 'c' ]] ] init_cond = [[[ 0 , 0 , 0 ], [ 0 , 0 , 0 ], 1 , True ], [[ 1 , 0 , 0 ], [ 0 , 0 , 0 ], 1 , False ], [[ 1 , 1 , 0 ], [ 0 , 0 , 0 ], 1 , False ] ] ps = ParticleSystem ( c_matrix , init_cond , params ) print ( ps ) ps . plot () pass","title":"Module src.particleSystem.ParticleSystem"},{"location":"reference/src/particleSystem/ParticleSystem/#classes","text":"","title":"Classes"},{"location":"reference/src/particleSystem/ParticleSystem/#particlesystem","text":"class ParticleSystem ( connectivity_matrix : list , initial_conditions : Union [ numpy . __array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . __nested_sequence . _NestedSequence [ numpy . __array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . __nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], sim_param : dict ) View Source class ParticleSystem : def __init__ ( self , connectivity_matrix : list , initial_conditions : npt . ArrayLike , sim_param : dict ) : \"\"\" Constructor for ParticleSystem object, model made up of n particles Parameters --------- connectivity_matrix : list 2-by-m matrix, where each column contains a nodal index pair that is connectedby a spring element. initial_conditions : npt.ArrayLike Array of n arrays to instantiate particles. Each subarray must contain the params required for the particle constructor: [initial_pos, initial_vel, mass, fixed: bool, constraint] param sim_param : dict Dictionary of other parameters required for simulation (dt, rtol, ...) \"\"\" self . __connectivity_matrix = connectivity_matrix self . __n = len ( initial_conditions ) self . __dt = sim_param [ \"dt\" ] self . __rtol = sim_param [ \"rel_tol\" ] self . __atol = sim_param [ \"abs_tol\" ] self . __maxiter = sim_param [ \"max_iter\" ] # allocate memory self . __particles = [] self . __springdampers = [] self . __f = np . zeros (( self . __n * 3 , )) self . __jx = np . zeros (( self . __n * 3 , self . __n * 3 )) self . __jv = np . zeros (( self . __n * 3 , self . __n * 3 )) self . __instantiate_particles ( initial_conditions ) self . __m_matrix = self . __construct_m_matrix () self . __instantiate_springdampers () # Variables required for kinetic damping self . __w_kin = self . __calc_kin_energy () self . __w_kin_min1 = self . __calc_kin_energy () self . __vis_damp = True self . __x_min1 = np . zeros ( self . __n , ) self . __x_min2 = np . zeros ( self . __n , ) return def __str__ ( self ) : print ( \"ParticleSystem object instantiated with attributes\\nConnectivity matrix:\" ) print ( self . __connectivity_matrix ) print ( \"Instantiated particles:\" ) n = 1 for particle in self . __particles : print ( f \" p{n}: \" , particle ) n += 1 return \"\" def __instantiate_particles ( self , initial_conditions : list ) : for set_of_initial_cond in initial_conditions : x = set_of_initial_cond [ 0 ] v = set_of_initial_cond [ 1 ] m = set_of_initial_cond [ 2 ] f = set_of_initial_cond [ 3 ] if f and len ( set_of_initial_cond ) >= 5 : con = set_of_initial_cond [ 4 ] con_t = set_of_initial_cond [ 5 ] self . __particles . append ( Particle ( x , v , m , f , con , con_t )) else : self . __particles . append ( Particle ( x , v , m , f )) return def __instantiate_springdampers ( self ) : for link in self . __connectivity_matrix : link = link . copy () #needed to not override the __connectivity_matrix link [ 0 ] = self . __particles [ link[0 ] ] link [ 1 ] = self . __particles [ link[1 ] ] self . __springdampers . append ( SpringDamper ( * link )) return def stress_self ( self , factor : float = 0 ) : \"\"\"Set all node lengths to zero to homogenously stress mesh\"\"\" if factor == 0 : for link in self . springdampers : link . l0 = 0 else : for link in self . springdampers : link . l0 *= factor return def __construct_m_matrix ( self ) : matrix = np . zeros (( self . __n * 3 , self . __n * 3 )) for i in range ( self . __n ) : matrix [ i*3:i*3+3, i*3:i*3+3 ] += np . identity ( 3 ) * self . __particles [ i ] . m return matrix def __calc_kin_energy ( self ) : v = self . __pack_v_current () w_kin = np . matmul ( np . matmul ( v , self . __m_matrix ), v . T ) # Kinetic energy , 0.5 constant can be neglected return w_kin def simulate ( self , f_external : npt . ArrayLike = ()) : if not len ( f_external ) : # check if external force is passed as argument , otherwise use 0 vector f_external = np . zeros ( self . __n * 3 , ) f = self . __one_d_force_vector () + f_external v_current = self . __pack_v_current () x_current = self . __pack_x_current () jx , jv = self . __system_jacobians () #jx = scipy . sparse . lil_array ( jx ) #jv = scipy . sparse . lil_array ( jv ) # constructing A matrix and b vector for solver A = self . __m_matrix - self . __dt * jv - self . __dt ** 2 * jx b = self . __dt * f + self . __dt ** 2 * jx . dot ( v_current ) # checking conditioning of A # print ( \"conditioning A:\" , np . linalg . cond ( A )) #A = scipy . sparse . bsr_array ( A ) # BiCGSTAB from scipy library dv , _ = bicgstab ( A , b , tol = self . __rtol , atol = self . __atol , maxiter = self . __maxiter ) # numerical time integration following implicit Euler scheme v_next = v_current + dv x_next = x_current + self . __dt * v_next # function returns the pos . and vel . for the next timestep , but for fixed particles this value doesn 't update! self.__update_x_v(x_next, v_next) return x_next, v_next def kin_damp_sim(self, f_ext: npt.ArrayLike = (), q_correction: bool = False): # kinetic damping algorithm if self.__vis_damp: # Condition resetting viscous damping to 0 for link in self.__springdampers: link.c = 0 self.__c = 0 self.__vis_damp = False if len(f_ext): # condition checking if an f_ext is passed as argument self.__save_state() x_next, v_next = self.simulate(f_ext) else: self.__save_state() x_next, v_next = self.simulate() w_kin_new = self.__calc_kin_energy() if w_kin_new > self.__w_kin: # kin damping algorithm, takes effect when decrease in kin energy is detected self.__update_w_kin(w_kin_new) else: v_next = np.zeros(self.__n*3, ) if q_correction: # statement to check if q_correction is desired, standard is turned off q = (self.__w_kin - w_kin_new)/(2*self.__w_kin - self.__w_kin_min1 - w_kin_new) # print(q) # print(self.__w_kin, w_kin_new) # !!! Not sure if linear interpolation between states is the way to determine new x_next !!! if q < 0.5: x_next = self.__x_min2 + (q / 0.5) * (self.__x_min1 - self.__x_min2) elif q == 0.5: x_next = self.__x_min1 elif q < 1: x_next = self.__x_min1 + ((q - 0.5) / 0.5) * (x_next - self.__x_min1) # Can also use this q factor to recalculate the state for certain timestep h self.__update_x_v(x_next, v_next) self.__update_w_kin(0) return x_next, v_next def __pack_v_current(self): return np.array([particle.v for particle in self.__particles]).flatten() def __pack_x_current(self): return np.array([particle.x for particle in self.__particles]).flatten() def __one_d_force_vector(self): self.__f[self.__f != 0] = 0 for n in range(len(self.__springdampers)): f_int = self.__springdampers[n].force_value() i, j, *_ = self.__connectivity_matrix[n] self.__f[i*3: i*3 + 3] += f_int self.__f[j*3: j*3 + 3] -= f_int return self.__f def __system_jacobians(self): self.__jx[self.__jx != 0] = 0 self.__jv[self.__jv != 0] = 0 for n in range(len(self.__springdampers)): jx, jv = self.__springdampers[n].calculate_jacobian() i, j, *_ = self.__connectivity_matrix[n] if self.__particles[i].fixed: if self.__particles[i].constraint_type == ' point ': jxplus = np.zeros([3,3]) jvplus = jxplus else: jxplus = self.__particles[i].constraint_projection_matrix.dot(jx) jvplus = self.__particles[i].constraint_projection_matrix.dot(jv) else: jxplus = jx jvplus = jv if self.__particles[j].fixed: if self.__particles[j].constraint_type == ' point ': jxmin = np.zeros([3,3]) jvmin = jxmin else: jxmin = self.__particles[j].constraint_projection_matrix.dot(jx) jvmin = self.__particles[j].constraint_projection_matrix.dot(jv) else: jxmin = jx jvmin = jv self.__jx[i * 3:i * 3 + 3, i * 3:i * 3 + 3] += jxplus self.__jx[j * 3:j * 3 + 3, j * 3:j * 3 + 3] += jxplus self.__jx[i * 3:i * 3 + 3, j * 3:j * 3 + 3] -= jxmin self.__jx[j * 3:j * 3 + 3, i * 3:i * 3 + 3] -= jxmin self.__jv[i * 3:i * 3 + 3, i * 3:i * 3 + 3] += jvplus self.__jv[j * 3:j * 3 + 3, j * 3:j * 3 + 3] += jvplus self.__jv[i * 3:i * 3 + 3, j * 3:j * 3 + 3] -= jvmin self.__jv[j * 3:j * 3 + 3, i * 3:i * 3 + 3] -= jvmin return self.__jx, self.__jv def __update_x_v(self, x_next: npt.ArrayLike, v_next: npt.ArrayLike): for i in range(self.__n): self.__particles[i].update_pos(x_next[i * 3:i * 3 + 3]) self.__particles[i].update_vel(v_next[i * 3:i * 3 + 3]) return def __update_w_kin(self, w_kin_new: float): self.__w_kin_min1 = self.__w_kin self.__w_kin = w_kin_new return def __save_state(self): self.__x_min2 = self.__x_min1 self.__x_min1 = self.__pack_x_current() return def find_reaction_forces(self): fixlist = [p.fixed for p in self.particles] projections = [p.constraint_projection_matrix for p in np.array(self.particles)[fixlist]] forces = self.__f.reshape((self.__n,3)) forces = -forces[fixlist] for i, projection in enumerate(projections): forces[i] -= projection.dot(forces[i].T).T return forces @property def particles(self): # @property decorators required, as PS info might be required for external calcs return self.__particles @property def springdampers(self): return self.__springdampers # @property # def stiffness_m(self): # self.__system_jacobians() # return self.__jx @property def kinetic_energy(self): return self.__w_kin @property def f_int(self): f_int = self.__f.copy() for i in range(len(self.__particles)): # need to exclude fixed particles for force-based convergence if self.__particles[i].fixed: f_int[i*3:(i+1)*3] = 0 return f_int @property def x_v_current(self): return self.__pack_x_current(), self.__pack_v_current() @property def x_v_current_3D(self): x = self.__pack_x_current() v = self.__pack_v_current() x = np.reshape(x, (int(len(x)/3),3)) v = np.reshape(v, (int(len(v)/3),3)) return x, v def plot(self): \"\"\"\"Plots current system configuration # TODO matplotlib styleguide recommends that helper functions take ax as an argument \"\"\" fig = plt.figure() ax = fig.add_subplot(projection=' 3 d ') fixlist = [] freelist = [] for particle in self.__particles: if particle.fixed: fixlist.append(particle.x) else: freelist.append(particle.x) fixlist = np.array(fixlist) freelist = np.array(freelist) ax.scatter(fixlist[:,0],fixlist[:,1],fixlist[:,2], color = ' red ', marker = ' o ') ax.scatter(freelist[:,0],freelist[:,1],freelist[:,2], color = ' blue ', marker = ' o ', s =5) segments = [] for link in self.__springdampers: segments.append(link.line_segment()) lc = Line3DCollection(segments, colors = ' black ', linewidths = 0.5) ax.add_collection3d(lc) ax.set_xlabel(' x ') ax.set_ylabel(' y ') ax.set_zlabel(' z ') ax.set_aspect(' equal ') return ax def initialize_find_surface(self, projection_plane: str = ' z '): \"\"\" performs triangulation and sets up conversion matrix for surface calc Projects the point cloud onto specified plane and performs triangulation. Then uses shape of current triangles to create a conversion matrix for assigning the areas of each triangle onto the nodes. Parameters ---------- projection_plane : str normal direction of plane for the mesh to be projected on for triangulation. Default: z Returns ------- simplices : list nested list of node indices that make up triangles conversion_matrix : npt.ArrayLike ndarray of shape n_nodes x n_triangles \"\"\" # Gathering points of nodes points = self.__pack_x_current() points = points.reshape((int(len(points)/3),3)) # Checking projection plane if projection_plane == ' x ': projection_plane = 0 elif projection_plane == ' y ': projection_plane = 1 elif projection_plane == ' z ': projection_plane = 2 else: raise AttributeError(\"projection_plane improperly defined; Must be x, y or z.\") # Performing triangulation points_projected = points[:,:projection_plane] # Projecting onto x-y plane tri = Delaunay(points_projected) # Finding areas of each triangle v1 = points[tri.simplices][:,0]-points[tri.simplices][:,1] v2 = points[tri.simplices][:,0]-points[tri.simplices][:,2] # Next we set up the matrix multiplication that will divide the areas # of the triangles over the actual nodes conversion_matrix = np.zeros((self.__n*3,len(tri.simplices)*3)) v1_length = np.linalg.norm(v1, axis=1) v2_length = np.linalg.norm(v2, axis=1) v3_length = np.linalg.norm(v2-v1, axis=1) angle_1 = np.arccos(np.sum(v1*v2, axis = 1)/(v1_length*v2_length)) angle_2 = np.arcsin(v2_length/v3_length * np.sin(angle_1)) angle_3 = np.pi - angle_1 - angle_2 angle_iterator = np.column_stack((angle_1, angle_2, angle_3)).flatten()/np.pi for j, indices in enumerate(tri.simplices): for k, i in enumerate(indices): conversion_matrix[3*i,3*j]+= angle_iterator[3*j+k] conversion_matrix[3*i+1,3*j+1]+= angle_iterator[3*j+k] conversion_matrix[3*i+2,3*j+2]+= angle_iterator[3*j+k] return tri.simplices, conversion_matrix def find_surface(self, projection_plane: str = ' z ') -> np.ndarray: \"\"\" finds the surface area vector for each node in the mesh Parameters ---------- projection_plane: passed to self.initialize_find_surface(). Returns ------- areas: npt.ArrayLike 3D area vectors for each node \"\"\" if not hasattr(self, ' _ParticleSystem__surface_conversion_matrix '): logging.warning(' find_surface called without prior initialization . ') simplices, conversion_matrix = self.initialize_find_surface() self.__simplices = simplices self.__surface_conversion_matrix = conversion_matrix else: conversion_matrix = self.__surface_conversion_matrix simplices = self.__simplices # Gathering points of nodes points = self.__pack_x_current() points = points.reshape((int(len(points)/3),3)) # Finding areas of each triangle v1 = points[simplices][:,0]-points[simplices][:,1] v2 = points[simplices][:,0]-points[simplices][:,2] area_vectors = np.cross(v1,v2)/2 # Now we transorm the simplice areas into nodal areas input_vector = area_vectors.flatten() area_vectors_1d = np.matmul(conversion_matrix,input_vector) area_vectors_redistributed = area_vectors_1d.reshape((self.__n,3)) return area_vectors_redistributed def plot_triangulated_surface(self): \"\"\" plots triangulated surface for user inspection \"\"\" # Gathering points of nodes points = self.__pack_x_current() points = points.reshape((int(len(points)/3),3)) x,y,z = points[:,0], points[:,1], points[:,2] area_vectors = self.find_surface() a_u = area_vectors[:,0] a_v = area_vectors[:,1] a_w = area_vectors[:,2] fig = plt.figure() ax = fig.add_subplot(projection=' 3 d ' ) ax . plot_trisurf ( x , y , z , triangles = self . __simplices , cmap = plt . cm . Spectral ) ax . scatter ( x , y , z ) ax . quiver ( x , y , z , a_u , a_v , a_w , length = 1 ) return ax","title":"ParticleSystem"},{"location":"reference/src/particleSystem/ParticleSystem/#instance-variables","text":"f_int kinetic_energy particles springdampers x_v_current x_v_current_3D","title":"Instance variables"},{"location":"reference/src/particleSystem/ParticleSystem/#methods","text":"","title":"Methods"},{"location":"reference/src/particleSystem/ParticleSystem/#find_reaction_forces","text":"def find_reaction_forces ( self ) View Source def find_reaction_forces ( self ) : fixlist = [ p.fixed for p in self.particles ] projections = [ p.constraint_projection_matrix for p in np.array(self.particles)[fixlist ] ] forces = self . __f . reshape (( self . __n , 3 )) forces = - forces [ fixlist ] for i , projection in enumerate ( projections ) : forces [ i ] -= projection . dot ( forces [ i ] . T ). T return forces","title":"find_reaction_forces"},{"location":"reference/src/particleSystem/ParticleSystem/#find_surface","text":"def find_surface ( self , projection_plane : str = 'z' ) -> numpy . ndarray finds the surface area vector for each node in the mesh Returns: Type Description npt.ArrayLike 3D area vectors for each node View Source def find_surface ( self , projection_plane : str = 'z' ) -> np . ndarray : \"\"\" finds the surface area vector for each node in the mesh Parameters ---------- projection_plane: passed to self.initialize_find_surface(). Returns ------- areas: npt.ArrayLike 3D area vectors for each node \"\"\" if not hasattr ( self , '_ParticleSystem__surface_conversion_matrix' ) : logging . warning ( 'find_surface called without prior initialization.' ) simplices , conversion_matrix = self . initialize_find_surface () self . __simplices = simplices self . __surface_conversion_matrix = conversion_matrix else : conversion_matrix = self . __surface_conversion_matrix simplices = self . __simplices # Gathering points of nodes points = self . __pack_x_current () points = points . reshape (( int ( len ( points ) / 3 ), 3 )) # Finding areas of each triangle v1 = points [ simplices ][ :,0 ]- points [ simplices ][ :,1 ] v2 = points [ simplices ][ :,0 ]- points [ simplices ][ :,2 ] area_vectors = np . cross ( v1 , v2 ) / 2 # Now we transorm the simplice areas into nodal areas input_vector = area_vectors . flatten () area_vectors_1d = np . matmul ( conversion_matrix , input_vector ) area_vectors_redistributed = area_vectors_1d . reshape (( self . __n , 3 )) return area_vectors_redistributed","title":"find_surface"},{"location":"reference/src/particleSystem/ParticleSystem/#initialize_find_surface","text":"def initialize_find_surface ( self , projection_plane : str = 'z' ) performs triangulation and sets up conversion matrix for surface calc Projects the point cloud onto specified plane and performs triangulation. Then uses shape of current triangles to create a conversion matrix for assigning the areas of each triangle onto the nodes. Parameters: Name Type Description Default projection_plane str normal direction of plane for the mesh to be projected on for triangulation. Default: z z Returns: Type Description list nested list of node indices that make up triangles View Source def initialize_find_surface ( self , projection_plane : str = 'z' ): \"\"\" performs triangulation and sets up conversion matrix for surface calc Projects the point cloud onto specified plane and performs triangulation. Then uses shape of current triangles to create a conversion matrix for assigning the areas of each triangle onto the nodes. Parameters ---------- projection_plane : str normal direction of plane for the mesh to be projected on for triangulation. Default: z Returns ------- simplices : list nested list of node indices that make up triangles conversion_matrix : npt.ArrayLike ndarray of shape n_nodes x n_triangles \"\"\" # Gathering points of nodes points = self . __pack_x_current () points = points . reshape (( int ( len ( points ) / 3 ), 3 )) # Checking projection plane if projection_plane == 'x' : projection_plane = 0 elif projection_plane == 'y' : projection_plane = 1 elif projection_plane == 'z' : projection_plane = 2 else : raise AttributeError ( \"projection_plane improperly defined; Must be x, y or z.\" ) # Performing triangulation points_projected = points [:,: projection_plane ] # Projecting onto x-y plane tri = Delaunay ( points_projected ) # Finding areas of each triangle v1 = points [ tri . simplices ][:, 0 ] - points [ tri . simplices ][:, 1 ] v2 = points [ tri . simplices ][:, 0 ] - points [ tri . simplices ][:, 2 ] # Next we set up the matrix multiplication that will divide the areas # of the triangles over the actual nodes conversion_matrix = np . zeros (( self . __n * 3 , len ( tri . simplices ) * 3 )) v1_length = np . linalg . norm ( v1 , axis = 1 ) v2_length = np . linalg . norm ( v2 , axis = 1 ) v3_length = np . linalg . norm ( v2 - v1 , axis = 1 ) angle_1 = np . arccos ( np . sum ( v1 * v2 , axis = 1 ) / ( v1_length * v2_length )) angle_2 = np . arcsin ( v2_length / v3_length * np . sin ( angle_1 )) angle_3 = np . pi - angle_1 - angle_2 angle_iterator = np . column_stack (( angle_1 , angle_2 , angle_3 )) . flatten () / np . pi for j , indices in enumerate ( tri . simplices ): for k , i in enumerate ( indices ): conversion_matrix [ 3 * i , 3 * j ] += angle_iterator [ 3 * j + k ] conversion_matrix [ 3 * i + 1 , 3 * j + 1 ] += angle_iterator [ 3 * j + k ] conversion_matrix [ 3 * i + 2 , 3 * j + 2 ] += angle_iterator [ 3 * j + k ] return tri . simplices , conversion_matrix","title":"initialize_find_surface"},{"location":"reference/src/particleSystem/ParticleSystem/#kin_damp_sim","text":"def kin_damp_sim ( self , f_ext : Union [ numpy . __array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . __nested_sequence . _NestedSequence [ numpy . __array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . __nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = (), q_correction : bool = False ) View Source def kin_damp_sim ( self , f_ext : npt . ArrayLike = () , q_correction : bool = False ) : # kinetic damping algorithm if self . __vis_damp : # Condition resetting viscous damping to 0 for link in self . __springdampers : link . c = 0 self . __c = 0 self . __vis_damp = False if len ( f_ext ) : # condition checking if an f_ext is passed as argument self . __save_state () x_next , v_next = self . simulate ( f_ext ) else : self . __save_state () x_next , v_next = self . simulate () w_kin_new = self . __calc_kin_energy () if w_kin_new > self . __w_kin : # kin damping algorithm , takes effect when decrease in kin energy is detected self . __update_w_kin ( w_kin_new ) else : v_next = np . zeros ( self . __n * 3 , ) if q_correction : # statement to check if q_correction is desired , standard is turned off q = ( self . __w_kin - w_kin_new ) / ( 2 * self . __w_kin - self . __w_kin_min1 - w_kin_new ) # print ( q ) # print ( self . __w_kin , w_kin_new ) # !!! Not sure if linear interpolation between states is the way to determine new x_next !!! if q < 0 . 5 : x_next = self . __x_min2 + ( q / 0 . 5 ) * ( self . __x_min1 - self . __x_min2 ) elif q == 0 . 5 : x_next = self . __x_min1 elif q < 1 : x_next = self . __x_min1 + (( q - 0 . 5 ) / 0 . 5 ) * ( x_next - self . __x_min1 ) # Can also use this q factor to recalculate the state for certain timestep h self . __update_x_v ( x_next , v_next ) self . __update_w_kin ( 0 ) return x_next , v_next","title":"kin_damp_sim"},{"location":"reference/src/particleSystem/ParticleSystem/#plot","text":"def plot ( self ) \"Plots current system configuration","title":"plot"},{"location":"reference/src/particleSystem/ParticleSystem/#todo-matplotlib-styleguide-recommends-that-helper-functions-take-ax-as-an-argument","text":"View Source def plot ( self ) : \"\"\"\" Plots current system configuration # TODO matplotlib styleguide recommends that helper functions take ax as an argument \"\" \" fig = plt.figure() ax = fig.add_subplot(projection='3d') fixlist = [] freelist = [] for particle in self.__particles: if particle.fixed: fixlist.append(particle.x) else: freelist.append(particle.x) fixlist = np.array(fixlist) freelist = np.array(freelist) ax.scatter(fixlist[:,0],fixlist[:,1],fixlist[:,2], color = 'red', marker = 'o') ax.scatter(freelist[:,0],freelist[:,1],freelist[:,2], color = 'blue', marker = 'o', s =5) segments = [] for link in self.__springdampers: segments.append(link.line_segment()) lc = Line3DCollection(segments, colors = 'black', linewidths = 0.5) ax.add_collection3d(lc) ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('z') ax.set_aspect('equal') return ax","title":"TODO matplotlib styleguide recommends that helper functions take ax as an argument"},{"location":"reference/src/particleSystem/ParticleSystem/#plot_triangulated_surface","text":"def plot_triangulated_surface ( self ) plots triangulated surface for user inspection View Source def plot_triangulated_surface ( self ): \"\"\" plots triangulated surface for user inspection \"\"\" # Gathering points of nodes points = self . __pack_x_current () points = points . reshape (( int ( len ( points ) / 3 ), 3 )) x , y , z = points [:, 0 ], points [:, 1 ], points [:, 2 ] area_vectors = self . find_surface () a_u = area_vectors [:, 0 ] a_v = area_vectors [:, 1 ] a_w = area_vectors [:, 2 ] fig = plt . figure () ax = fig . add_subplot ( projection = ' 3 d ' ) ax . plot_trisurf ( x , y , z , triangles = self . __simplices , cmap = plt . cm . Spectral ) ax . scatter ( x , y , z ) ax . quiver ( x , y , z , a_u , a_v , a_w , length = 1 ) return ax","title":"plot_triangulated_surface"},{"location":"reference/src/particleSystem/ParticleSystem/#simulate","text":"def simulate ( self , f_external : Union [ numpy . __array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . __nested_sequence . _NestedSequence [ numpy . __array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . __nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = () ) View Source def simulate ( self , f_external : npt . ArrayLike = ()): if not len ( f_external ): # check if external force is passed as argument , otherwise use 0 vector f_external = np . zeros ( self . __n * 3 , ) f = self . __one_d_force_vector () + f_external v_current = self . __pack_v_current () x_current = self . __pack_x_current () jx , jv = self . __system_jacobians () # jx = scipy . sparse . lil_array ( jx ) # jv = scipy . sparse . lil_array ( jv ) # constructing A matrix and b vector for solver A = self . __m_matrix - self . __dt * jv - self . __dt ** 2 * jx b = self . __dt * f + self . __dt ** 2 * jx . dot ( v_current ) # checking conditioning of A # print ( \"conditioning A:\" , np . linalg . cond ( A )) # A = scipy . sparse . bsr_array ( A ) # BiCGSTAB from scipy library dv , _ = bicgstab ( A , b , tol = self . __rtol , atol = self . __atol , maxiter = self . __maxiter ) # numerical time integration following implicit Euler scheme v_next = v_current + dv x_next = x_current + self . __dt * v_next # function returns the pos . and vel . for the next timestep , but for fixed particles this value doesn ' t update ! self . __update_x_v ( x_next , v_next ) return x_next , v_next","title":"simulate"},{"location":"reference/src/particleSystem/ParticleSystem/#stress_self","text":"def stress_self ( self , factor : float = 0 ) Set all node lengths to zero to homogenously stress mesh View Source def stress_self ( self , factor : float = 0 ) : \"\"\"Set all node lengths to zero to homogenously stress mesh\"\"\" if factor == 0 : for link in self . springdampers : link . l0 = 0 else : for link in self . springdampers : link . l0 *= factor return","title":"stress_self"},{"location":"reference/src/particleSystem/SpringDamper/","text":"Module src.particleSystem.SpringDamper Child Class 'SpringDamper', for spring-damper objects to be instantiated in ParticleSystem View Source \"\"\" Child Class 'SpringDamper', for spring-damper objects to be instantiated in ParticleSystem \"\"\" from enum import Enum import numpy as np from src.particleSystem.ImplicitForce import ImplicitForce from src.particleSystem.Particle import Particle class SpringDamperType ( Enum ): \"\"\" Enumeration representing the various types of SpringDamper objects. Attributes ---------- DEFAULT : str Represents the default SpringDamper type, which has standard characteristics. NONCOMPRESSIVE : str Represents a SpringDamper that cannot be compressed, only stretched. NONTENSILE : str Represents a SpringDamper that cannot be stretched, only compressed. Notes ----- The SpringDamper type affects the initialization and behavior of the SpringDamper objects. Each type might have specific properties or behaviors associated with it in the SpringDamper class. \"\"\" DEFAULT = \"default\" NONCOMPRESSIVE = \"noncompressive\" NONTENSILE = \"nontensile\" class SpringDamper ( ImplicitForce ): \"\"\" #TODO one line summary Attributes: #TODO finish this \"\"\" def __init__ ( self , p1 : Particle , p2 : Particle , k : float , c : float , linktype = SpringDamperType . DEFAULT ): \"\"\"Initializes the spring damper Args: p1, p2: The two Particle instances to be connected k: A float representing the stiffness of the spring in N/m. c: A float representing the damping coefficient in Ns/m linktype: A SpringDamperType enum representing the properties of the link See SpringDamperType for more information \"\"\" super () . __init__ ( p1 , p2 ) self . __k = k self . __c = c self . __l0 = np . linalg . norm ( self . __relative_pos ()) self . __linktype = linktype return def __str__ ( self ): return f \"SpringDamper object, spring stiffness [n/m]: { self . __k } , rest length [m]: { self . l0 } \\n \" \\ f \"Damping coefficient [N s/m]: { self . __c } \\n \" \\ f \"Assigned particles \\n p1: { self . p1 } \\n p2: { self . p2 } \\n \" \\ f \"Link type: { self . __linktype } \" def __relative_pos ( self ): return np . array ([ self . p1 . x - self . p2 . x ]) def __relative_vel ( self ): return np . array ([ self . p1 . v - self . p2 . v ]) def force_value ( self ): if self . __linktype == SpringDamperType . DEFAULT : return self . __calculate_f_spring () + self . __calculate_f_damping () elif self . __linktype == SpringDamperType . NONCOMPRESSIVE : l = np . linalg . norm ( self . __relative_pos ()) if l >= self . l0 : return self . __calculate_f_spring () + self . __calculate_f_damping () else : return np . array ([ 0 , 0 , 0 ]) elif self . __linktype == SpringDamperType . NONTENSILE : l = np . linalg . norm ( self . __relative_pos ()) if l <= self . l0 : return self . __calculate_f_spring () + self . __calculate_f_damping () else : return np . array ([ 0 , 0 , 0 ]) def __calculate_f_spring ( self ): relative_pos = self . __relative_pos () norm_pos = np . linalg . norm ( relative_pos ) if norm_pos != 0 : unit_vector = relative_pos / norm_pos else : unit_vector = np . array ([ 0 , 0 , 0 ]) f_spring = - self . __k * ( norm_pos - self . l0 ) * unit_vector return np . squeeze ( f_spring ) def __calculate_f_damping ( self ): relative_pos = self . __relative_pos () relative_vel = np . squeeze ( self . __relative_vel ()) norm_pos = np . linalg . norm ( relative_pos ) if norm_pos != 0 : unit_vector = np . squeeze ( relative_pos / norm_pos ) else : unit_vector = np . squeeze ( np . array ([ 0 , 0 , 0 ])) f_damping = - self . __c * np . dot ( relative_vel , unit_vector ) * unit_vector return np . squeeze ( f_damping ) def calculate_jacobian ( self ): relative_pos = self . __relative_pos () norm_pos = np . linalg . norm ( relative_pos ) # Using guard classes to return early in special cases if ( self . __linktype == SpringDamperType . NONCOMPRESSIVE and norm_pos <= self . __l0 ): return np . zeros ( 3 ) elif ( self . __linktype == SpringDamperType . NONTENSILE and norm_pos >= self . __l0 ): return np . zeros ( 3 ) if norm_pos != 0 : unit_vector = relative_pos / norm_pos else : norm_pos = 1 unit_vector = np . array ([ 0 , 0 , 0 ]) i = np . identity ( 3 ) T = np . matmul ( np . transpose ( unit_vector ), unit_vector ) jx = - self . __k * (( self . l0 / norm_pos - 1 ) * ( T - i ) + T ) jv = - self . __c * i return jx , jv def line_segment ( self ): \"\"\"Returns coordinate tuple of particles at either end of segment\"\"\" return ( self . p1 . x , self . p2 . x ) @property def l0 ( self ): return self . __l0 @l0 . setter def l0 ( self , value ): # Exposed to enable self-stressing of mesh self . __l0 = value @property def c ( self ): return self . __c @c . setter def c ( self , value ): # Exposed to enable resetting when using kinetic damping self . __c = value if __name__ == \"__main__\" : particle1 = Particle ([ 0 , 0 , 0 ], [ 0 , 0 , 0 ], 1 , False ) particle2 = Particle ([ 0 , 0 , 1 ], [ 0 , 0 , 1 ], 1 , False ) stiffness = 1e5 damping = 10 rest_length = 0 linktype = 'noncomp' springdamper = SpringDamper ( particle1 , particle2 , stiffness , damping ) print ( springdamper ) print () print ( springdamper . force_value ()) # print((np.sqrt(3)-1)*1e5/np.sqrt(3)) # value check print () print ( springdamper . calculate_jacobian ()) pass Classes SpringDamper class SpringDamper ( p1 : src . particleSystem . Particle . Particle , p2 : src . particleSystem . Particle . Particle , k : float , c : float , linktype =< SpringDamperType . DEFAULT : 'default' > ) TODO one line summary Attributes: #TODO finish this View Source class SpringDamper ( ImplicitForce ) : \"\"\" #TODO one line summary Attributes: #TODO finish this \"\"\" def __init__ ( self , p1 : Particle , p2 : Particle , k : float , c : float , linktype = SpringDamperType . DEFAULT ) : \"\"\"Initializes the spring damper Args: p1, p2: The two Particle instances to be connected k: A float representing the stiffness of the spring in N/m. c: A float representing the damping coefficient in Ns/m linktype: A SpringDamperType enum representing the properties of the link See SpringDamperType for more information \"\"\" super (). __init__ ( p1 , p2 ) self . __k = k self . __c = c self . __l0 = np . linalg . norm ( self . __relative_pos ()) self . __linktype = linktype return def __str__ ( self ) : return f \"SpringDamper object, spring stiffness [n/m]: {self.__k}, rest length [m]: {self.l0}\\n\" \\ f \"Damping coefficient [N s/m]: {self.__c}\\n\" \\ f \"Assigned particles\\n p1: {self.p1}\\n p2: {self.p2}\\n\" \\ f \"Link type: {self.__linktype}\" def __relative_pos ( self ) : return np . array ( [ self.p1.x - self.p2.x ] ) def __relative_vel ( self ) : return np . array ( [ self.p1.v - self.p2.v ] ) def force_value ( self ) : if self . __linktype == SpringDamperType . DEFAULT : return self . __calculate_f_spring () + self . __calculate_f_damping () elif self . __linktype == SpringDamperType . NONCOMPRESSIVE : l = np . linalg . norm ( self . __relative_pos ()) if l >= self . l0 : return self . __calculate_f_spring () + self . __calculate_f_damping () else : return np . array ( [ 0, 0, 0 ] ) elif self . __linktype == SpringDamperType . NONTENSILE : l = np . linalg . norm ( self . __relative_pos ()) if l <= self . l0 : return self . __calculate_f_spring () + self . __calculate_f_damping () else : return np . array ( [ 0, 0, 0 ] ) def __calculate_f_spring ( self ) : relative_pos = self . __relative_pos () norm_pos = np . linalg . norm ( relative_pos ) if norm_pos != 0 : unit_vector = relative_pos / norm_pos else : unit_vector = np . array ( [ 0, 0, 0 ] ) f_spring = - self . __k * ( norm_pos - self . l0 ) * unit_vector return np . squeeze ( f_spring ) def __calculate_f_damping ( self ) : relative_pos = self . __relative_pos () relative_vel = np . squeeze ( self . __relative_vel ()) norm_pos = np . linalg . norm ( relative_pos ) if norm_pos != 0 : unit_vector = np . squeeze ( relative_pos / norm_pos ) else : unit_vector = np . squeeze ( np . array ( [ 0, 0, 0 ] )) f_damping = - self . __c * np . dot ( relative_vel , unit_vector ) * unit_vector return np . squeeze ( f_damping ) def calculate_jacobian ( self ) : relative_pos = self . __relative_pos () norm_pos = np . linalg . norm ( relative_pos ) # Using guard classes to return early in special cases if ( self . __linktype == SpringDamperType . NONCOMPRESSIVE and norm_pos <= self . __l0 ) : return np . zeros ( 3 ) elif ( self . __linktype == SpringDamperType . NONTENSILE and norm_pos >= self . __l0 ) : return np . zeros ( 3 ) if norm_pos != 0 : unit_vector = relative_pos / norm_pos else : norm_pos = 1 unit_vector = np . array ( [ 0, 0, 0 ] ) i = np . identity ( 3 ) T = np . matmul ( np . transpose ( unit_vector ), unit_vector ) jx = - self . __k * (( self . l0 / norm_pos - 1 ) * ( T - i ) + T ) jv = - self . __c * i return jx , jv def line_segment ( self ) : \"\"\"Returns coordinate tuple of particles at either end of segment\"\"\" return ( self . p1 . x , self . p2 . x ) @property def l0 ( self ) : return self . __l0 @l0 . setter def l0 ( self , value ) : # Exposed to enable self - stressing of mesh self . __l0 = value @property def c ( self ) : return self . __c @c . setter def c ( self , value ) : # Exposed to enable resetting when using kinetic damping self . __c = value Ancestors (in MRO) src.particleSystem.ImplicitForce.ImplicitForce src.particleSystem.Force.Force src.particleSystem.SystemObject.SystemObject abc.ABC Instance variables c l0 p1 p2 Methods calculate_jacobian def calculate_jacobian ( self ) View Source def calculate_jacobian ( self ): relative_pos = self . __relative_pos () norm_pos = np . linalg . norm ( relative_pos ) # Using guard classes to return early in special cases if ( self . __linktype == SpringDamperType . NONCOMPRESSIVE and norm_pos <= self . __l0 ): return np . zeros ( 3 ) elif ( self . __linktype == SpringDamperType . NONTENSILE and norm_pos >= self . __l0 ): return np . zeros ( 3 ) if norm_pos != 0 : unit_vector = relative_pos / norm_pos else : norm_pos = 1 unit_vector = np . array ([ 0 , 0 , 0 ]) i = np . identity ( 3 ) T = np . matmul ( np . transpose ( unit_vector ), unit_vector ) jx = - self . __k * (( self . l0 / norm_pos - 1 ) * ( T - i ) + T ) jv = - self . __c * i return jx , jv force_value def force_value ( self ) View Source def force_value ( self ): if self . __linktype == SpringDamperType . DEFAULT : return self . __calculate_f_spring () + self . __calculate_f_damping () elif self . __linktype == SpringDamperType . NONCOMPRESSIVE : l = np . linalg . norm ( self . __relative_pos ()) if l >= self . l0 : return self . __calculate_f_spring () + self . __calculate_f_damping () else : return np . array ([ 0 , 0 , 0 ]) elif self . __linktype == SpringDamperType . NONTENSILE : l = np . linalg . norm ( self . __relative_pos ()) if l <= self . l0 : return self . __calculate_f_spring () + self . __calculate_f_damping () else : return np . array ([ 0 , 0 , 0 ]) line_segment def line_segment ( self ) Returns coordinate tuple of particles at either end of segment View Source def line_segment ( self ) : \"\"\"Returns coordinate tuple of particles at either end of segment\"\"\" return ( self . p1 . x , self . p2 . x ) SpringDamperType class SpringDamperType ( / , * args , ** kwargs ) Enumeration representing the various types of SpringDamper objects. Attributes Name Type Description Default DEFAULT str Represents the default SpringDamper type, which has standard characteristics. SpringDamper NONCOMPRESSIVE str Represents a SpringDamper that cannot be compressed, only stretched. None NONTENSILE str Represents a SpringDamper that cannot be stretched, only compressed. None View Source class SpringDamperType ( Enum ): \"\"\" Enumeration representing the various types of SpringDamper objects. Attributes ---------- DEFAULT : str Represents the default SpringDamper type, which has standard characteristics. NONCOMPRESSIVE : str Represents a SpringDamper that cannot be compressed, only stretched. NONTENSILE : str Represents a SpringDamper that cannot be stretched, only compressed. Notes ----- The SpringDamper type affects the initialization and behavior of the SpringDamper objects. Each type might have specific properties or behaviors associated with it in the SpringDamper class. \"\"\" DEFAULT = \"default\" NONCOMPRESSIVE = \"noncompressive\" NONTENSILE = \"nontensile\" Ancestors (in MRO) enum.Enum Class variables DEFAULT NONCOMPRESSIVE NONTENSILE name value","title":"Springdamper"},{"location":"reference/src/particleSystem/SpringDamper/#module-srcparticlesystemspringdamper","text":"Child Class 'SpringDamper', for spring-damper objects to be instantiated in ParticleSystem View Source \"\"\" Child Class 'SpringDamper', for spring-damper objects to be instantiated in ParticleSystem \"\"\" from enum import Enum import numpy as np from src.particleSystem.ImplicitForce import ImplicitForce from src.particleSystem.Particle import Particle class SpringDamperType ( Enum ): \"\"\" Enumeration representing the various types of SpringDamper objects. Attributes ---------- DEFAULT : str Represents the default SpringDamper type, which has standard characteristics. NONCOMPRESSIVE : str Represents a SpringDamper that cannot be compressed, only stretched. NONTENSILE : str Represents a SpringDamper that cannot be stretched, only compressed. Notes ----- The SpringDamper type affects the initialization and behavior of the SpringDamper objects. Each type might have specific properties or behaviors associated with it in the SpringDamper class. \"\"\" DEFAULT = \"default\" NONCOMPRESSIVE = \"noncompressive\" NONTENSILE = \"nontensile\" class SpringDamper ( ImplicitForce ): \"\"\" #TODO one line summary Attributes: #TODO finish this \"\"\" def __init__ ( self , p1 : Particle , p2 : Particle , k : float , c : float , linktype = SpringDamperType . DEFAULT ): \"\"\"Initializes the spring damper Args: p1, p2: The two Particle instances to be connected k: A float representing the stiffness of the spring in N/m. c: A float representing the damping coefficient in Ns/m linktype: A SpringDamperType enum representing the properties of the link See SpringDamperType for more information \"\"\" super () . __init__ ( p1 , p2 ) self . __k = k self . __c = c self . __l0 = np . linalg . norm ( self . __relative_pos ()) self . __linktype = linktype return def __str__ ( self ): return f \"SpringDamper object, spring stiffness [n/m]: { self . __k } , rest length [m]: { self . l0 } \\n \" \\ f \"Damping coefficient [N s/m]: { self . __c } \\n \" \\ f \"Assigned particles \\n p1: { self . p1 } \\n p2: { self . p2 } \\n \" \\ f \"Link type: { self . __linktype } \" def __relative_pos ( self ): return np . array ([ self . p1 . x - self . p2 . x ]) def __relative_vel ( self ): return np . array ([ self . p1 . v - self . p2 . v ]) def force_value ( self ): if self . __linktype == SpringDamperType . DEFAULT : return self . __calculate_f_spring () + self . __calculate_f_damping () elif self . __linktype == SpringDamperType . NONCOMPRESSIVE : l = np . linalg . norm ( self . __relative_pos ()) if l >= self . l0 : return self . __calculate_f_spring () + self . __calculate_f_damping () else : return np . array ([ 0 , 0 , 0 ]) elif self . __linktype == SpringDamperType . NONTENSILE : l = np . linalg . norm ( self . __relative_pos ()) if l <= self . l0 : return self . __calculate_f_spring () + self . __calculate_f_damping () else : return np . array ([ 0 , 0 , 0 ]) def __calculate_f_spring ( self ): relative_pos = self . __relative_pos () norm_pos = np . linalg . norm ( relative_pos ) if norm_pos != 0 : unit_vector = relative_pos / norm_pos else : unit_vector = np . array ([ 0 , 0 , 0 ]) f_spring = - self . __k * ( norm_pos - self . l0 ) * unit_vector return np . squeeze ( f_spring ) def __calculate_f_damping ( self ): relative_pos = self . __relative_pos () relative_vel = np . squeeze ( self . __relative_vel ()) norm_pos = np . linalg . norm ( relative_pos ) if norm_pos != 0 : unit_vector = np . squeeze ( relative_pos / norm_pos ) else : unit_vector = np . squeeze ( np . array ([ 0 , 0 , 0 ])) f_damping = - self . __c * np . dot ( relative_vel , unit_vector ) * unit_vector return np . squeeze ( f_damping ) def calculate_jacobian ( self ): relative_pos = self . __relative_pos () norm_pos = np . linalg . norm ( relative_pos ) # Using guard classes to return early in special cases if ( self . __linktype == SpringDamperType . NONCOMPRESSIVE and norm_pos <= self . __l0 ): return np . zeros ( 3 ) elif ( self . __linktype == SpringDamperType . NONTENSILE and norm_pos >= self . __l0 ): return np . zeros ( 3 ) if norm_pos != 0 : unit_vector = relative_pos / norm_pos else : norm_pos = 1 unit_vector = np . array ([ 0 , 0 , 0 ]) i = np . identity ( 3 ) T = np . matmul ( np . transpose ( unit_vector ), unit_vector ) jx = - self . __k * (( self . l0 / norm_pos - 1 ) * ( T - i ) + T ) jv = - self . __c * i return jx , jv def line_segment ( self ): \"\"\"Returns coordinate tuple of particles at either end of segment\"\"\" return ( self . p1 . x , self . p2 . x ) @property def l0 ( self ): return self . __l0 @l0 . setter def l0 ( self , value ): # Exposed to enable self-stressing of mesh self . __l0 = value @property def c ( self ): return self . __c @c . setter def c ( self , value ): # Exposed to enable resetting when using kinetic damping self . __c = value if __name__ == \"__main__\" : particle1 = Particle ([ 0 , 0 , 0 ], [ 0 , 0 , 0 ], 1 , False ) particle2 = Particle ([ 0 , 0 , 1 ], [ 0 , 0 , 1 ], 1 , False ) stiffness = 1e5 damping = 10 rest_length = 0 linktype = 'noncomp' springdamper = SpringDamper ( particle1 , particle2 , stiffness , damping ) print ( springdamper ) print () print ( springdamper . force_value ()) # print((np.sqrt(3)-1)*1e5/np.sqrt(3)) # value check print () print ( springdamper . calculate_jacobian ()) pass","title":"Module src.particleSystem.SpringDamper"},{"location":"reference/src/particleSystem/SpringDamper/#classes","text":"","title":"Classes"},{"location":"reference/src/particleSystem/SpringDamper/#springdamper","text":"class SpringDamper ( p1 : src . particleSystem . Particle . Particle , p2 : src . particleSystem . Particle . Particle , k : float , c : float , linktype =< SpringDamperType . DEFAULT : 'default' > )","title":"SpringDamper"},{"location":"reference/src/particleSystem/SpringDamper/#todo-one-line-summary","text":"Attributes: #TODO finish this View Source class SpringDamper ( ImplicitForce ) : \"\"\" #TODO one line summary Attributes: #TODO finish this \"\"\" def __init__ ( self , p1 : Particle , p2 : Particle , k : float , c : float , linktype = SpringDamperType . DEFAULT ) : \"\"\"Initializes the spring damper Args: p1, p2: The two Particle instances to be connected k: A float representing the stiffness of the spring in N/m. c: A float representing the damping coefficient in Ns/m linktype: A SpringDamperType enum representing the properties of the link See SpringDamperType for more information \"\"\" super (). __init__ ( p1 , p2 ) self . __k = k self . __c = c self . __l0 = np . linalg . norm ( self . __relative_pos ()) self . __linktype = linktype return def __str__ ( self ) : return f \"SpringDamper object, spring stiffness [n/m]: {self.__k}, rest length [m]: {self.l0}\\n\" \\ f \"Damping coefficient [N s/m]: {self.__c}\\n\" \\ f \"Assigned particles\\n p1: {self.p1}\\n p2: {self.p2}\\n\" \\ f \"Link type: {self.__linktype}\" def __relative_pos ( self ) : return np . array ( [ self.p1.x - self.p2.x ] ) def __relative_vel ( self ) : return np . array ( [ self.p1.v - self.p2.v ] ) def force_value ( self ) : if self . __linktype == SpringDamperType . DEFAULT : return self . __calculate_f_spring () + self . __calculate_f_damping () elif self . __linktype == SpringDamperType . NONCOMPRESSIVE : l = np . linalg . norm ( self . __relative_pos ()) if l >= self . l0 : return self . __calculate_f_spring () + self . __calculate_f_damping () else : return np . array ( [ 0, 0, 0 ] ) elif self . __linktype == SpringDamperType . NONTENSILE : l = np . linalg . norm ( self . __relative_pos ()) if l <= self . l0 : return self . __calculate_f_spring () + self . __calculate_f_damping () else : return np . array ( [ 0, 0, 0 ] ) def __calculate_f_spring ( self ) : relative_pos = self . __relative_pos () norm_pos = np . linalg . norm ( relative_pos ) if norm_pos != 0 : unit_vector = relative_pos / norm_pos else : unit_vector = np . array ( [ 0, 0, 0 ] ) f_spring = - self . __k * ( norm_pos - self . l0 ) * unit_vector return np . squeeze ( f_spring ) def __calculate_f_damping ( self ) : relative_pos = self . __relative_pos () relative_vel = np . squeeze ( self . __relative_vel ()) norm_pos = np . linalg . norm ( relative_pos ) if norm_pos != 0 : unit_vector = np . squeeze ( relative_pos / norm_pos ) else : unit_vector = np . squeeze ( np . array ( [ 0, 0, 0 ] )) f_damping = - self . __c * np . dot ( relative_vel , unit_vector ) * unit_vector return np . squeeze ( f_damping ) def calculate_jacobian ( self ) : relative_pos = self . __relative_pos () norm_pos = np . linalg . norm ( relative_pos ) # Using guard classes to return early in special cases if ( self . __linktype == SpringDamperType . NONCOMPRESSIVE and norm_pos <= self . __l0 ) : return np . zeros ( 3 ) elif ( self . __linktype == SpringDamperType . NONTENSILE and norm_pos >= self . __l0 ) : return np . zeros ( 3 ) if norm_pos != 0 : unit_vector = relative_pos / norm_pos else : norm_pos = 1 unit_vector = np . array ( [ 0, 0, 0 ] ) i = np . identity ( 3 ) T = np . matmul ( np . transpose ( unit_vector ), unit_vector ) jx = - self . __k * (( self . l0 / norm_pos - 1 ) * ( T - i ) + T ) jv = - self . __c * i return jx , jv def line_segment ( self ) : \"\"\"Returns coordinate tuple of particles at either end of segment\"\"\" return ( self . p1 . x , self . p2 . x ) @property def l0 ( self ) : return self . __l0 @l0 . setter def l0 ( self , value ) : # Exposed to enable self - stressing of mesh self . __l0 = value @property def c ( self ) : return self . __c @c . setter def c ( self , value ) : # Exposed to enable resetting when using kinetic damping self . __c = value","title":"TODO one line summary"},{"location":"reference/src/particleSystem/SpringDamper/#ancestors-in-mro","text":"src.particleSystem.ImplicitForce.ImplicitForce src.particleSystem.Force.Force src.particleSystem.SystemObject.SystemObject abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/src/particleSystem/SpringDamper/#instance-variables","text":"c l0 p1 p2","title":"Instance variables"},{"location":"reference/src/particleSystem/SpringDamper/#methods","text":"","title":"Methods"},{"location":"reference/src/particleSystem/SpringDamper/#calculate_jacobian","text":"def calculate_jacobian ( self ) View Source def calculate_jacobian ( self ): relative_pos = self . __relative_pos () norm_pos = np . linalg . norm ( relative_pos ) # Using guard classes to return early in special cases if ( self . __linktype == SpringDamperType . NONCOMPRESSIVE and norm_pos <= self . __l0 ): return np . zeros ( 3 ) elif ( self . __linktype == SpringDamperType . NONTENSILE and norm_pos >= self . __l0 ): return np . zeros ( 3 ) if norm_pos != 0 : unit_vector = relative_pos / norm_pos else : norm_pos = 1 unit_vector = np . array ([ 0 , 0 , 0 ]) i = np . identity ( 3 ) T = np . matmul ( np . transpose ( unit_vector ), unit_vector ) jx = - self . __k * (( self . l0 / norm_pos - 1 ) * ( T - i ) + T ) jv = - self . __c * i return jx , jv","title":"calculate_jacobian"},{"location":"reference/src/particleSystem/SpringDamper/#force_value","text":"def force_value ( self ) View Source def force_value ( self ): if self . __linktype == SpringDamperType . DEFAULT : return self . __calculate_f_spring () + self . __calculate_f_damping () elif self . __linktype == SpringDamperType . NONCOMPRESSIVE : l = np . linalg . norm ( self . __relative_pos ()) if l >= self . l0 : return self . __calculate_f_spring () + self . __calculate_f_damping () else : return np . array ([ 0 , 0 , 0 ]) elif self . __linktype == SpringDamperType . NONTENSILE : l = np . linalg . norm ( self . __relative_pos ()) if l <= self . l0 : return self . __calculate_f_spring () + self . __calculate_f_damping () else : return np . array ([ 0 , 0 , 0 ])","title":"force_value"},{"location":"reference/src/particleSystem/SpringDamper/#line_segment","text":"def line_segment ( self ) Returns coordinate tuple of particles at either end of segment View Source def line_segment ( self ) : \"\"\"Returns coordinate tuple of particles at either end of segment\"\"\" return ( self . p1 . x , self . p2 . x )","title":"line_segment"},{"location":"reference/src/particleSystem/SpringDamper/#springdampertype","text":"class SpringDamperType ( / , * args , ** kwargs ) Enumeration representing the various types of SpringDamper objects.","title":"SpringDamperType"},{"location":"reference/src/particleSystem/SpringDamper/#attributes","text":"Name Type Description Default DEFAULT str Represents the default SpringDamper type, which has standard characteristics. SpringDamper NONCOMPRESSIVE str Represents a SpringDamper that cannot be compressed, only stretched. None NONTENSILE str Represents a SpringDamper that cannot be stretched, only compressed. None View Source class SpringDamperType ( Enum ): \"\"\" Enumeration representing the various types of SpringDamper objects. Attributes ---------- DEFAULT : str Represents the default SpringDamper type, which has standard characteristics. NONCOMPRESSIVE : str Represents a SpringDamper that cannot be compressed, only stretched. NONTENSILE : str Represents a SpringDamper that cannot be stretched, only compressed. Notes ----- The SpringDamper type affects the initialization and behavior of the SpringDamper objects. Each type might have specific properties or behaviors associated with it in the SpringDamper class. \"\"\" DEFAULT = \"default\" NONCOMPRESSIVE = \"noncompressive\" NONTENSILE = \"nontensile\"","title":"Attributes"},{"location":"reference/src/particleSystem/SpringDamper/#ancestors-in-mro_1","text":"enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/src/particleSystem/SpringDamper/#class-variables","text":"DEFAULT NONCOMPRESSIVE NONTENSILE name value","title":"Class variables"}]}